fa9f9233f429644023a92acabafb77c0 ; 114 ; 24 ; 150 ; 42 ; Use DeMorgan's law to take advantage of NANDs and NORs, as these take fewer MOSFETs in CMOS.
fa9f9233f429644023a92acabafb77c0 ; 114 ; 24 ; 96 ; 21 ; Be clever! You can re-use outputs in places you wouldn't expect.
8cc6d2a93758f98e50bfa268da4fa6c0 ; 114 ; 24 ; 132 ; 33 ; The lab suggests computing Cout using 3 NAND2 gates and 1 NAND3 gate. Attempt to use this pattern to reduce the number of FETs used to computer Cout. A NAND gate would replace the existing AND gate (with inputs B and Cin). This would replace the OR gate (inverted NOR requires more FETs!) and the NAND2 gate with a since NAND3.        Recall that:    Cout = AB + ACin + BCin    = ~(AB) + ~(ACin) + ~(BCin)        Since we use a NAND3 gate instead of an AND3 gate, we do not need to invert the output.
8cc6d2a93758f98e50bfa268da4fa6c0 ; 114 ; 24 ; 96 ; 21 ; I would hint that there is overlap in calculating Cout and S.        Once the provided Cin equation is assessed, it is clear that -- other than AB -- either A or B must be true when Cin is true to yield Cout. This essentially translates into Cin * A XOR B.
644b13b08a995295040191c4f21e2f74 ; 114 ; 24 ; 132 ; 33 ; I would suggest using a nand2 for b and cin and changing the last or gate into a nand3 gate.  This produces the same logic table but uses gates that require less mosfets.  
644b13b08a995295040191c4f21e2f74 ; 114 ; 24 ; 96 ; 21 ; Use the output of a xor b for one of the nand2 gates.  This eliminates the need to create the nand gates for a nand cin as well as b nand cin.  
4aa6a3bba08bf9f7c6e63c5eecbbaeb5 ; 96 ; 21 ; 132 ; 33 ; Think about reusing computed values (e.g. A ^ B). Reusing values reduces the number of components needed (but may increase propagation delay).        Think about manipulating gates in sequence to convert them to NANDs and NORs (which use less gates than ANDs or ORs, because CMOS is good for implementing inverting logic). DeMorgan's Laws can be used to do this. For example, something like (~A OR ~B) could be implemented as ~(A NAND B), which requires fewer gates.        In general, the problem of finding an optimal gate configuration is hard, but the two techniques mentioned above can be a useful guide.
eec2331c5412314329017b2d2ba39c92 ; 114 ; 24 ; 132 ; 33 ; Mutate the boolean function for Cout such that all OR and AND operations are being NOT'ed. This allows you to design a circuit using only naturally inverting CMOS gates.
eec2331c5412314329017b2d2ba39c92 ; 114 ; 24 ; 96 ; 21 ; I would ask: is there a way for you to use some intermediate node in one circuit to bypass a CMOS gate in the other, leading to a reduction of used mosfets?
0a2eccf80ad7ef5df7c61c37a1b43132 ; 114 ; 24 ; 132 ; 33 ; Consider a more efficient way of implementing your carry operation.
0a2eccf80ad7ef5df7c61c37a1b43132 ; 114 ; 24 ; 96 ; 21 ; Instead of considering standard gates, think of specific transistor solutions for calculating the carry and sum bits.
716d75cc57fd3e3de7ac3104361b2914 ; 114 ; 24 ; 132 ; 33 ; I would advise them to use three 2-input NANDs and one 3-input NAND, configured in Sum-of-Products to detect the cases where the carry-out should be nonzero.
716d75cc57fd3e3de7ac3104361b2914 ; 114 ; 24 ; 96 ; 21 ; Use intermediate steps from the cascaded XOR gates.
9d3567b78def8924c263e9d8ed31d758 ; 114 ; 24 ; 132 ; 33 ; Use demorgans law and think about cascading 2input nands with a 3input nand. It is more efficient to use only inverting logic. 
9d3567b78def8924c263e9d8ed31d758 ; 114 ; 24 ; 96 ; 21 ; Think of the logic overlap between S and Cout and share the gates between them.    Think of how to use the XORs you already have to use for S in constructing Cout
6de7799ecd47ece1dfaadd8ff938f14c ; 96 ; 18 ; 132 ; 33 ; Looking at the logic of the cout, it should be pretty obvious that the logic is the opposite of inverting. Ergo, adding an inverter (a small investment) can flip it so that the outputs are in fact inverting, and the logic can all be done with just one gate. This decreases both the time for this logic (shortest path now shorter) and the number of MOSFETs needed since more efficiently done.
c39d2e7b1b54d3e189691b8ca901322d ; 114 ; 24 ; 132 ; 33 ; Instead of having B AND Cin, you could also make it a NAND. Then, you can have a three-input NAND to combine them instead of the 2-input NAND and the 2-input OR (remember that by Demorgan's Law two cascaded NANDs are logically equivalent to a cascade of AND/OR).
c39d2e7b1b54d3e189691b8ca901322d ; 114 ; 24 ; 96 ; 21 ; Try to combine your circuit - you can use some of the gates in the S output as part of your Cout output (common elements = less gates overall!)
83225ad3552e2f8fee8b920850651d1e ; 114 ; 24 ; 132 ; 33 ; I would give the advice that CMOS gates are naturally inverting, and therefore when implementing larger logic functions, the more one can use inverting sub-logic (such as NOR and NAND gates), the less mosfets the design will end up needing.  For example, the Cout schema shown above uses an AND and an OR gate in series, both of which take more mosfets to make than their counterparts NAND and NOR because they require inverters.  I would suggest observing the cascading of NAND gates and see how that accomplishes nearly the same logic as cascading AND/OR, while using less mosfets.  If further guidance is needed, I would also suggest using a 3-input NAND gate where the inputs are the outputs of three 2-input NAND gates.  To explain this, I would use Demorgan's Law to show how a 3-input NAND gate can be used to compute the OR of 3 inversed inputs.
83225ad3552e2f8fee8b920850651d1e ; 114 ; 24 ; 96 ; 21 ; I would have the student look at their solution and observe that S and Cout are being implemented separately.  I would then tell them that there are likely simplifications that can be found by looking at intermediary computations in each of the schemas and seeing how they can be applied to the other.  In this case, we see that after the first XOR of the S schema, the result can be put through cascading NANDs to achieve the same output.  Using Demorgan's Law again, I would work backwards and show how the output we want can be achieved from a various combinations of inputs.  One of these combinations would correspond to something quite close to the above solution, and I would give the final hint that a 2-input XOR gate only differs from a 2-input OR gate when the inputs are both 1's.  This allows for a bit of simplification since we have already computed XOR, but I would note that this is a tricky design to figure out.
83eceded93349c3b88b411687dc4896c ; 114 ; 24 ; 132 ; 33 ; For Cout, rather than combining NAND(AB) and NAND(AC) into another two-input NAND, you could just take the NAND3 of NAND(AB), NAND(AC), and NAND(BC), which would use far fewer mosfets as you wouldn't need the inverters necessary for OR and AND.
83eceded93349c3b88b411687dc4896c ; 114 ; 24 ; 96 ; 21 ; Rather than making the S and Cout as two separate modules, you could use the work you've already done to get an XOR of A and B to then not need to use three full NAND2 and a NAND3 circuit. By avoiding modularization of separate outputs you can save a lot of unnecessary repetition of logic.
7a183418841e4e34554b127c38a258eb ; 72 ; 22 ; 132 ; 33 ; Implement XOR gate using transmission-gate-logic for S. Implement complex ('lump') gate with mosfet-sharing and output inverter for Cout.
0a6274500b7f16cf1e9950dd0d3015f2 ; 126 ; 30 ; example=expected ; example=expected ; Since the gate-level design matches mine, I would say to be more careful about your sub-circuit design.  I know that I used 2 more mosfets than necessary in the xor implementation, and therefore must also have used 2 more mosfets than necessary in nand.
0a6274500b7f16cf1e9950dd0d3015f2 ; 126 ; 30 ; 96 ; 21 ; If you work through the truth table of two parallel nands with a common input and an xor of the different inputs cascaded into a nands with the common input, you find them to be identical.  This makes the previous design and this one identical.
6d24f715fca44ce35bb550922d18c953 ; 96 ; 21 ; 132 ; 33 ; I would say that the two outputs do not need to have completely separate sets of combinational logic gates. It is more efficient if you look for ways they can overlap so that you don't have to calculate the same thing multiple times.
a93ed42befb01026353ec6531129d842 ; 132 ; 36 ; example=expected ; example=expected ; Do not try to be too clever with C_out--design your schematic as the expression is written. This way you will achieve the schematic shown in Comparison #1.
a93ed42befb01026353ec6531129d842 ; 132 ; 36 ; 96 ; 21 ; Keep in mind that although expressions like XOR and OR are not equivalent in isolation, when combined in a larger expression, they may serve the same purpose. Because you've already found the XOR of A and B for example, you can then use that as the OR of A and B when you know A AND B will be ANDed with A XOR B later on.
490c4360225293a8c3cd0d1982599d92 ; 92 ; 20 ; 132 ; 33 ; Try to write a SOP for Cout and use DeMorgan's. You did it correctly for the AB and ACin part. Try to use the same reasoning for BCin part too. It will require just slight changes are you are good to go. Remember how many fets are required for every gate and that the CMOS logic is inherently inverting.
6b2c495eb23b252cd430adb4c47a31df ; 114 ; 24 ; 132 ; 33 ; We can get away with using a smaller circuit to compute Cout. To find an alternative implementation, apply DeMorgan's law to the expression of complement of the complement of Cout. The specific case that turns out to be useful elsewhere too is that or of and-s is equivalent to nand of nand-s.
6b2c495eb23b252cd430adb4c47a31df ; 114 ; 24 ; 96 ; 21 ; Let's try rewriting Cout using the xor of two inputs that we already compute -- maybe we can utilize that to save circuit space. Observe that Cout is only 0 in these cases:    - A=0, B=0    - A=1, B=0, C=0    - A=0, B=1, C=0    Does any part of this table look like something we have already computed? How many mosfets would computing the rest take, and how many would we need to get to Cout from there?
aaf6eeee00bdf5a7675f3549a67d5b02 ; 114 ; 30 ; 132 ; 33 ; Focus on simplifying your model. There are many simple equivalents that can substituted in the circuit. Try using more universal gates and combining it with your XOR. 
aaf6eeee00bdf5a7675f3549a67d5b02 ; 114 ; 30 ; 96 ; 21 ; Try to remove unnecessary components of the circuit. Use your engineering mind and try to remove needless parts that are equivalent. Replace the And gates with NAND gates and try to use substitute the NOR Gate with NAND implementations. 
ef68581e3c9d574a39f6f467d26a3e50 ; 114 ; 24 ; 132 ; 33 ; Use Demorgan's Law to simplify.
ef68581e3c9d574a39f6f467d26a3e50 ; 114 ; 24 ; 96 ; 21 ; Don't calculate the same thing twice. If one part of your circuit gives you information that can be used elsewhere, take advantage of it.
3a0135f9157447e16da5c17863f1531c ; 114 ; 24 ; 132 ; 33 ; Recall that it should take 4 mosfets to make a 2-input NAND gate, and 6 for 2-input OR and 2-input AND gates.        Also, realize that DeMorgan's Law applies regardless of the number of inputs, and just as you implemented the first two AND-ORs with NAND gates, you can also implement all three with a three-input NAND gate, which takes 6 mosfets to implement, saving you 6 of them per FA module.
3a0135f9157447e16da5c17863f1531c ; 114 ; 24 ; 96 ; 21 ; Consider combining your circuits to compute S and Cout.        You can simplify your circuit for Cout if you consider A XOR B as a "free" computation since you compute it for S anyway. You can simply NAND (A XOR B) with Cin to replace ACin + BCin. Though they aren't exactly the same, because you NAND that with A NAND B, your overall circuit still takes into account the fact that you want it to return 1 when both A and B are 1 as well.
6b0f707e959cfb7a8d6c50793039cb9e ; 150 ; 36 ; example=expected ; example=expected ; Reduce the number of MOSFETs in your XOR implementation (instead of using 4 NANDs like I did).
6b0f707e959cfb7a8d6c50793039cb9e ; 150 ; 36 ; 96 ; 21 ; Take advantage of the intermediate outputs from the output process of S and implement that into the Cout process -- a 3-input NAND gate is not necessary.
b736c4acdd55a8f7626ac2e370aaabdf ; 114 ; 24 ; 132 ; 33 ; For one, avoid using ORs and ANDs when you can use NANDS and NORs.     It requires using inverters which may not always be necessary.     Also look for ways of combining NANDs and NORs because you can often reduce     the number of mosfets by combining several ORs and ANDs into a few NORs and NANDs.
b736c4acdd55a8f7626ac2e370aaabdf ; 114 ; 24 ; 96 ; 21 ; Look at the logic table, and from the minimal sum equations look for patterns that can take advantage of signals generated by other parts of your logic, in order to remove unnecessary logic used to create that signal.
019399af6748b14edf24bb4c63520095 ; 114 ; 24 ; 132 ; 33 ; You have implemented S with 2 XOR gates. That's good!         However, for Cout, you can reduce the number of MOSFETS you use by using exclusively NAND2 and NAND3 gates, since they use fewer mosfets than AND and OR gates. To do this, use DeMorgan's law and see that A*B + A*C + B*C can be rewritten to not(not(A*B) * not(A*C) * not(B*C)) !!
019399af6748b14edf24bb4c63520095 ; 114 ; 24 ; 96 ; 21 ; You do not have to treat S and Cout as completely independent processes! Try to re-use some of the MOSFETS you have used in calculating S to get Cout.        A*B + A*C + B*C can be rewritten to not(not(A*B) * not(A*C) * not(B*C)).        Now, we notice that not(A*C) * not(B*C) can be re-written as not((A (+) B)*C). This is hard to get by DeMorgan's law but we can think about it intuitively. In the first expression, if A-&gt;0 and B-&gt;0, or if A-&gt;1 and B-&gt;1 then we want to get 1 no matter what C is. However, if A-&gt;0 and C-&gt;0, then B must not be 0 in order to get 1. Similarly, if B-&gt;0 and C-&gt;0, A cannot be 0. This is basically equivalent to using an XOR. Once we realize this, it is easy to see how to re-write the expression.
c840b7b9beff727cbe36ed8e3f04ea51 ; 114 ; 24 ; 132 ; 33 ; Convert the cascaded AND/OR into cascaded NANDS
c840b7b9beff727cbe36ed8e3f04ea51 ; 114 ; 24 ; 96 ; 21 ; Don't calculate S and Cout completely separately. Use intermediate steps in S to calculate Cout.
34b25b45d8783b8eb96563a87f2ed99e ; 114 ; 24 ; 132 ; 33 ; Try implementing a 3-input NAND; it may save you some mosfets
34b25b45d8783b8eb96563a87f2ed99e ; 114 ; 24 ; 96 ; 21 ; Think about what calculations are common between the two outputs; maybe you could save some mosfets by centralizing those
4e430e7479201f968997f52393a385a8 ; 114 ; 24 ; 132 ; 33 ; I would tell them that they should try to optimize the times they use gates that can be implemented with only one CMOS gate, such as NAND and NOR. In their computation of Cout, they use an AND and an OR, and they can use demorgan's law to instead simplify this to NANDs and NORs, so they use less gates, and then less mosfets.
4e430e7479201f968997f52393a385a8 ; 114 ; 24 ; 96 ; 21 ; Instead of thinking of S and Cout as have completely separate gates, they could use internal outputs from S in Cout to make calculating parts of Cout easier.
dd0ee4aa584f539800e1443fdf250d38 ; 114 ; 24 ; 132 ; 33 ; I'd tell the student that he put NAND(A,B) and NAND(A, Cin) into a NAND gate to get OR(AND(A,B), AND(A, Cin)), and then had to stick that into an OR gate with AND(B, Cin), which is bad because not only are you using an extra two gates, but they both can't be implemented with a single CMOS gate so you'd need to add inverters. I'd hint at using a 3-input NAND gate.
dd0ee4aa584f539800e1443fdf250d38 ; 114 ; 24 ; 96 ; 21 ; I'd say that it's possible to reuse some of the results from the XOR gates in calculating Cout, and tell the student to think about what happens if you put XOR(A, B) as one input in a NAND gate.
066d19110cf76f222ad425dc9c1dc85e ; 114 ; 24 ; 132 ; 33 ; Use a 3-input Nand to reduce the number of gates needed.
066d19110cf76f222ad425dc9c1dc85e ; 114 ; 24 ; 96 ; 21 ; Use the hints provided by the lab, but try to improve on them.
e9cd056e4e5a6f0ac610fb3119fb7458 ; 114 ; 24 ; 132 ; 33 ; I think first I'd ask to make sure they knew what a NAND3 was, because I think a solution like this might come from not totally understanding how it works. After going over that, I'd talk with them about how the last NAND and NOR worked together, and ask whether a NAND3 would also work. Maybe with a lot of paper and some tables.
e9cd056e4e5a6f0ac610fb3119fb7458 ; 114 ; 24 ; 96 ; 21 ; Show them the piece that makes S and the piece that makes Cout and talk about how you could use nodes from S to get Cout, probably with more tables, since at least I really appreciate the visual aid.
3333b20bc8d5938ce956a57191e6dae7 ; 114 ; 24 ; 144 ; 36 ; Use negative logic (aka NAND and NOR) instead of AND and OR, because CMOS logic is naturally inverting. Since an AND gate is a NAND with an inverter and an OR gate is a NOR gate with a inverter, using NAND and NOR will reduce the number of mosfets used.
3333b20bc8d5938ce956a57191e6dae7 ; 114 ; 24 ; 96 ; 21 ; Note that in the process of calculating S, the XOR of A and B was already computed. Instead of building the Cout circuit completely separate from the S circuit, we can take advantage of the computations done in calculating S to make calculating Cout easier.
7bdc7019379bb29e6a623bf2087440a1 ; 126 ; 30 ; example=expected ; example=expected ; Directly inverting methods tend to be more efficient in CMOS implementations. Perhaps you should try to change the Cout portion of your full adder to use solely NAND gates?
7bdc7019379bb29e6a623bf2087440a1 ; 126 ; 30 ; 96 ; 21 ; Do you think you can combine the logic for S and the logic for Cout to get a more efficient solution? Consider how the first three NAND gates combine.
74d870f4de0a3f0721bf8bafe862c7d0 ; 114 ; 24 ; 144 ; 36 ; If you find the sum-of-products expression for Cout from the truth table, you get:    Cout = not(Ci)AB + not(A)CiB + not(B)CiA + CiAB    This simplifies to: AB + Ci(not(A)B + not(B)A) = AB + Ci*XOR(A,B), which is what the student represented. This is one way to encode Cout- however, it can be further simplified. Using a Karnaugh map, you can simplify Cout to AB + BCin + ACin. This is equal to NAND(NAND(A,B),NAND(B,C), NAND(A,C)). The first encoding has to be expressed in positive logic, and, therefore requires more mosfets. So, my advice would be to use a Karnaugh map to make sure you have completely simplified your sum-of-products expression. Additionally, express your logic function in terms of negative logic to reduce the number of mosfets.
74d870f4de0a3f0721bf8bafe862c7d0 ; 114 ; 24 ; 96 ; 21 ; Rather than thinking of your two outputs as distinct circuits, try to use the logic from one circuit to reduce the number of mosfets in another. Instead of inputting A and B into an XOR logic gate twice, as in the setup in Comparison #1, utilize the XOR gate from the first output to reduce the number of mosfets used.
d99971cd82b8a98383b5797dcf1b20f6 ; 114 ; 24 ; 144 ; 36 ; Take a look at the carry circuit and ask why you use a XOR gate, because that alone takes 10 mosfets. 
d99971cd82b8a98383b5797dcf1b20f6 ; 114 ; 24 ; 96 ; 21 ; Do your logic only once. Is there any logic that is common to both the carry and summation branches?
9cea50c5d1ccd2e4c463a965dbeb2bde ; 96 ; 21 ; 144 ; 36 ; Compare the two components of your design. Do they have any gates with inputs in common? If so, could you use this to your advantage to minimize the number of mosfets you are using by combining the two components at the site of overlap?
560e4b43d3f3b71073762bea2969fce9 ; 114 ; 24 ; 144 ; 36 ; Use a 3 input NAND to compute Cout.
560e4b43d3f3b71073762bea2969fce9 ; 114 ; 24 ; 96 ; 21 ; I should take advantage of the fact that S already computes A XOR B.
a63b3ae4f55843c31324fd182182c383 ; 126 ; 30 ; example=expected ; example=expected ; I would say to use 3 gated NAND gate to save MOSFET. 
a63b3ae4f55843c31324fd182182c383 ; 126 ; 30 ; 96 ; 21 ; Try to combine the gates used in S with Cout. 
ac94f44b7d6e929ac373183c6f475d47 ; 114 ; 24 ; 132 ; 36 ; It could be more efficient to use NANDs and NORs rather than ANDs and ORs because in CMOS, ANDs and ORs are implemented by placing an inverter onto the NAND/NOR output.
ac94f44b7d6e929ac373183c6f475d47 ; 114 ; 24 ; 96 ; 21 ; I would tell them to think outside the box and try to manipulate their current logic equation into a way that a XOR that was used previously to get the S output to be of use when getting the Cout output.
bd8b0457b979082459f19d0cff058a9c ; 114 ; 24 ; 132 ; 36 ; Use NAND2 gates and NAND3 gates instead of regular AND and OR gates. Use DeMorgan's Theorem to find this.
bd8b0457b979082459f19d0cff058a9c ; 114 ; 24 ; 96 ; 21 ; Try to combine both systems together using the same inputs.
56a52ca84890ee3f80ddb385b698ba38 ; 114 ; 27 ; 132 ; 36 ; Try using NAND and NOR gates as opposed to AND and OR gates, as they are more computationally efficient and use few MOSFETs.
56a52ca84890ee3f80ddb385b698ba38 ; 114 ; 27 ; 96 ; 21 ; Look at your computations for S and Cout. Do they share any computations in common? (e.g. A AND B). If so, can you combine these computations to one, to make the circuit more efficient? If not, can you think of a way to change your circuit logic so that the computations for S and Cout share computations in common? 
4ddbc7e5f2a67e7009ae50d58e94ecbb ; 114 ; 24 ; 132 ; 36 ; The solution translates to: Cout = (A+B)*Cin+B*Cin=A*Cin + B*Cin. It lacks term A*B. It's incorrect. 
4ddbc7e5f2a67e7009ae50d58e94ecbb ; 114 ; 24 ; 96 ; 21 ; By computing S and Cout separately, we wasted from intermediate result that can be used in both calculation of S and Cout. 
ba00176d698c22dbdf655457537de988 ; 114 ; 24 ; 132 ; 36 ; Instead of using AND and OR gates to find Cout, try to use NAND gates, because inverting gates are faster than non-inverting ones and requires less mosfets.
ba00176d698c22dbdf655457537de988 ; 114 ; 24 ; 96 ; 21 ; The implementation for S and Cout doesn't have to be completely independent modules. You used XOR gates while implementing S. Is there a way you can incorporate XOR into your logic equation for Cout so you can "reuse resources"? Try "factoring" Cin out of the given logic equation to make an XOR gate, and then using 3 NAND gates to connect to the rest of the components together.
b8912e4f7c425ce017bd33cc83937970 ; 114 ; 24 ; 132 ; 36 ; Use Boolean algebra to convert the A, B, Cin sub-circuit producing Cout into a new sub-circuit that uses only NAND gates.  The new sub-circuit uses fewer mosfets than the design shown.
b8912e4f7c425ce017bd33cc83937970 ; 114 ; 24 ; 96 ; 21 ; Try to reuse mosfets and make use of mosfets not necessarily tied to the value being computed in order to maximize efficiency.  Not every sub-circuit design necessarily requires a completely new set of mosfets.
d3bb17a1122f4c38ef31f645275039b8 ; 96 ; 18 ; 132 ; 36 ; Write out the truth table for a section of the circuit that contains multiple gates. See if you can build a circuit to spec with that table that uses fewer mosfets. You may have to look at sections with more than 2 inputs and one output.
afc426011bfcb4bf36c1640f8f4f1047 ; 114 ; 24 ; 132 ; 36 ; using a 3 input nand could help with saving both time and number of mosfets used
afc426011bfcb4bf36c1640f8f4f1047 ; 114 ; 24 ; 96 ; 21 ; using more nand gates can decrease the number of mosfets you will need to use
6a796ddf660ddf10b7323414321d2a1b ; 96 ; 21 ; 132 ; 36 ; Try combining the top and bottom parts of the design. You should be able to find a way to use certain components in the logic of S in the logic of Cout as well.
4452cdcd785a4158adcb70c91b1535f8 ; 114 ; 24 ; 150 ; 42 ; I would tell the student to consider using DeMorgans Law. I don't think that it's possible to further simplify the cascading XOR gates; however, the circuit shown below that can be simplified. From DeMorgan we know that a Nand gate is equivalent to an Or gate with inverted inputs. Therefore, we can turn the two Or gates in this circuit into Nand gates as long as we invert their inputs. For the two upper And gates we can invert their outputs (and thus invert the input of the upper Or gate) by turning them into Nand gates. We can then invert the output of this upper Or gate with an inverter. We then turn the lower And gate into a Nand gate and the final Or gate into a Nand gate and we have converted this circuit to consist solely of Nand gates and an inverter. Nand gates use 4 mosfets where as an And and Or gates use 6 mosfets - thus we have significantly reduced the number of mosfets we need to use.
4452cdcd785a4158adcb70c91b1535f8 ; 114 ; 24 ; 96 ; 21 ; I would tell them that, as I did, they probably did not consider that you can combine the portions of the circuit that calculate S and Cout. I made these two elements be calculated completely separately but it is much more efficient and intuitive to combine them.
1e5c8de295705eb3742c6b6a581cf5f8 ; 114 ; 30 ; 150 ; 42 ; Condense the two upper AND gates and the OR gate connected to them by using the equivalent output for the top XOR gate. The output of the XOR A(notB) + (notA)B is a component in the Cout output. 
1e5c8de295705eb3742c6b6a581cf5f8 ; 114 ; 30 ; 96 ; 21 ; By applying De Morgan's law to the lower half of the circuit, one can condense the OR of AND gates into the not(AND) of the two inputs.
5941e7fb9d59ce13f66966a19c505c2d ; 114 ; 24 ; 150 ; 42 ; S seems fine if we are assuming that XOR takes 10 mosfets. Apparently we can reduce this down to 6 in a very nontrivial way.        Cout could be output in a more efficient way. For one, you should try to implement logic using nand/nor, as they use less mosfets. The lab suggested the use of 3 2-input NANDs and 1 3-input NANDs, which in itself is a more efficient implementation. To implement a 3-input NAND, you can either cascade 2 2-input NANDs or hard code it using mosfets. Either way, you use 6 mosfets for the 3-input NAND
5941e7fb9d59ce13f66966a19c505c2d ; 114 ; 24 ; 96 ; 21 ; Be creative. You don't have to keep S and Cout as two separate/independent CMOS gates. Try using the output or intermediate of one as an input of another.
eeafed8bc863a264f59621ed4d3f3489 ; 114 ; 24 ; 150 ; 42 ; This advice was already given in the lab instructions: try cascading NANDS instead of ANDs and ORs.        More generically, I would tell them to try to avoid using a lot of AND and OR gates because generally there is a simpler solution. An AND gate is really a NAND followed by an inverter (similarly, an OR gate is a NOR followed by an inverter). This is why they are both 6 mosfets, they're a simpler four mosfet gate followed by a two mosfet inverter.        Thinking of improving module efficiency as reducing the number of mosfets by reducing the number of gates helped me to understand why cascading ANDs and ORs would be inefficient. Because just by looking at this drawing, it doesn't seem terribly inefficient. But if you replaced each AND and OR gate with their two gate equivalents then you can easily see how inefficient it really is.
eeafed8bc863a264f59621ed4d3f3489 ; 114 ; 24 ; 96 ; 21 ; First, I'd tell them to think about combining logic from their implementation for S and their implementation for Cout. If you're implementing a single module, FA, then it probably shouldn't be equivalent to two separate modules, S and Cout.        I would tell them to see if any of the intermediary steps in either half could be used to simplify the other. And I would probably try to lead them to simplify their Cout because their S is already very efficient, though that depends a bit on how big of a hint they want/need. (Especially because it feels intuitive to me that they should try to simplify Cout because it is longer than S, but if they were getting thrown off by that then I'd step in with more advice).        One way to lead them into it: "Think about your output after each gate. Could that output allow you to reach the output of the other half more efficiently than your current design does?" Thinking about it in terms of truth tables or the equations would probably help, depending on the student. I might try telling them to try changing their equation for Cout to include something that was already found in S, for example.
16e1443383c042600b26781268fa2e69 ; 152 ; 40 ; example=expected ; example=expected ; Consider the logic that can be replaced by less gates.
16e1443383c042600b26781268fa2e69 ; 152 ; 40 ; 96 ; 21 ; Recognize the output voltages that are repeated in the circuit. Afterwards, recognize transformations that can allow you to do the same logic with less gates and more output/input sharing.
8809bed990639fff8ad14d384c49f1cd ; 114 ; 24 ; 150 ; 42 ; Instead of using 3 AND2 gates and 2 OR2 gates, we can use 3 NAND2 gates and 1 NAND3 gate. NAND gates require less mosfets to implement, so they are useful for reducing mosfet usage. 
8809bed990639fff8ad14d384c49f1cd ; 114 ; 24 ; 96 ; 21 ; Rather than using separate gates to get S and Cout, you should share gates between the two. This is analogous to killing two bird with one stone. 
68c3b498771b9d6063fc725a4faa96ec ; 114 ; 24 ; 150 ; 42 ; Since MOS is a logically inverting technology, using inverting gates can save MOSFETS. Apply DeMorgan's law on the logical formula "AB + BCin + ACin" to turn it into "NOT(NOT(AB)NOT(BCin)NOT(ACin))," so that it is the composition of 3 NANDs with a 3-input NAND. This way we avoid implementing many unnecessary internal inverters.
68c3b498771b9d6063fc725a4faa96ec ; 114 ; 24 ; 96 ; 21 ; Once you've decided on an implementation for part of the circuit, see if there are any ways to reuse the internal signals you've already generated. Though there may be some redundancy in the formula representation, great savings may be had. For example, the desired output on Cout is "AB + BCin + ACin," but XOR(A, B)+AB (where XOR is "XOR(Q, Z) := NOT(Q)Z+QNOT(Z)") is just (A + B) + AB, so multiplying a Cin onto the XOR yields "XOR(A, B)Cin + AB" = "ACin + BCin + AB," the desired result having reused the XOR signal from earlier.
7b57df76f6e54bf5b4bf6498c29052dc ; 114 ; 24 ; 150 ; 42 ; Use DeMorgan's law to reduce Cout to natural CMOS gates
7b57df76f6e54bf5b4bf6498c29052dc ; 114 ; 24 ; 96 ; 21 ; Be efficient and use gates multiple times where possible. I actually had this logical expression for Cout but didn't think to reuse the A xor B from the S circuit.
7ab7c196d53d89cef941843b69f3d1b7 ; 114 ; 30 ; 150 ; 42 ; Try simplifying the Cout circuit by implementing 2-input and 3-input NAND gates rather than AND and OR gates. (This should also reduce the propagation time).
7ab7c196d53d89cef941843b69f3d1b7 ; 114 ; 30 ; 96 ; 21 ; Try using the XOR gates utilized for the S-output to reduce the number of MOSFETs needed for the Cout.  Specifically, look for a way to eliminate the need for your 3-input NAND gate.
1ef18e94ec8f66af684c4b9af3611ded ; 114 ; 24 ; 150 ; 42 ; There is a hint in the question which leads to better solution. Ask the student if he/she had read the hint and understood it.
1ef18e94ec8f66af684c4b9af3611ded ; 114 ; 24 ; 96 ; 21 ; Let the student observe the better solution to find out what makes it better, and learn from it.
c778228063483a5fb98cd345b1651453 ; 114 ; 30 ; 150 ; 42 ; You are using 2 2-input-OR gates to represent a 3-input-OR gate. If this was replaced with a 3 input OR gate it would would potentially increase it's speed as there is a lot of leniency with an OR gate as we can given out output as soon as know that one of the inputs is a "1". The ACin and BCin combination can also be replaced by linking the A XOR B combination with an and gate with Cin. This would further reduce the total number of mosfets.
c778228063483a5fb98cd345b1651453 ; 114 ; 30 ; 96 ; 21 ; If you look at the truth table, we can see that Cout is only "1" when there are only 2 or 3 inputs as valid "1". What is a clever way of detecting if there is only one "1" and then negate that value to produce a "1" for Cout whenever that is not the case.
6ffdb974418ac331f39c01fc396b5818 ; 66 ; 21 ; 150 ; 42 ; First of all, try to optimize your full adder. The two outputs are being computed completely independently at the moment, but it's actually possible to share gates between the two parts of the circuit if you arrange them in a clever way.        Secondly, do you actually need a full adder for the lowest bit?         Thirdly, push the limits of CMOS logic. If you stare at it for a very long time, you can find an XOR gate that uses only 9 MOSFETs. Even better, if you forget about the restriction that inputs can't directly connect to outputs, you can make an XOR out of 6 MOSFETs. Now, that isn't a valid combinational gate, so you can't chain a bunch of them together. However, as long as that XOR doesn't sit directly between inputs and outputs in your full adder, you can use as one of the XORs in the full adder -- the other gates will ensure that the full adder stays a combinational device.    
84419611fb5d8fbbd99aae3444b30aab ; 114 ; 24 ; 150 ; 42 ; The "and" and "or" gates in the Cout path can be simplified to a simpler combination of NANDS, decreasing the number of mosfets, simplifying the design, and improving run time. 
84419611fb5d8fbbd99aae3444b30aab ; 114 ; 24 ; 96 ; 21 ; This design does a beautiful job of simplifying the circuit by using the Ci as an input to both the XOR gate in the S path and the NAND gate in the Cout path, thus simplifying the Cout cascade and reducing run time since the S and Cout cascades are connected. 
96eaf74c76bc5de45e508479599c65a1 ; 114 ; 24 ; 150 ; 42 ; Each AND and OR gate implements an inverter, which takes more MOSFETs than necessary.  The advantage to using NANDs for Co is that you need not implement inverters.
96eaf74c76bc5de45e508479599c65a1 ; 114 ; 24 ; 96 ; 21 ; Try to figure out a way to preserve outputs that you used in one circuit to implement into another output.  As opposed to separating S and Cout into 2 circuits, take values from one circuit and use them in your other, and hence combining the two into one.  
d5c0df7ba64b5dcde9a9b5d7c041f207 ; 72 ; 25 ; 150 ; 42 ; //... enter your advice here        A Full Adder can be implemented much more effectively than above by using half adders (XOR for S and AND (NAND then INV) for C) or even more efficiently than that by using two "inverse carry" half adders (XOR for S and just NAND for C) and combining their "inverse" carries with a NAND gate instead of combining the two complete half adders with an OR (NOR then INV) gate. That significantly reduces the number of MOSFETs already by setting up a better full adder.        Also, the XOR gate, which is obviously essential to the half and full adder sum gate portion can be implemented with as little as 6 MOSFETs and would also significantly bring down the count.     
d9983d6a06af1c5d65779a1d3a6e78bf ; 114 ; 24 ; 150 ; 42 ; I would tell them that their solution would have passed the checkoff back in 2013, but now they need to use inverting logic because their FA isn't fast enough.
d9983d6a06af1c5d65779a1d3a6e78bf ; 114 ; 24 ; 96 ; 21 ; You can use the outputs from the XORs in your calculation for the carry bit. They don't have to be separate calculations.
0e087844b6389f8ac8f1b56185d3bfad ; 114 ; 24 ; 150 ; 42 ; Since CMOS is inverting, the ands and ors can be made faster by using nands instead. 
0e087844b6389f8ac8f1b56185d3bfad ; 114 ; 24 ; 96 ; 21 ; The two elements of the output of a full adder need not be reached separately. 
06264ae1dc36ac30c8dd345f4f7055a6 ; 126 ; 30 ; example=expected ; example=expected ; Improve your three input nand gate to make it more efficient, as it currently involves the use of an inverter
06264ae1dc36ac30c8dd345f4f7055a6 ; 126 ; 30 ; 96 ; 21 ; Consider combining the partial results of S in your Cout circuit to drastically reduce the number of mosfets
4b8255dace3ccdde0c5c87043c4f5651 ; 114 ; 24 ; 126 ; 27 ; I would show them that they are computng the XOR of A and B twice, which increases the number of mosfets. XORs take many mosfets to implement, so reusing outputs would greatly improve the circuit. Using fewer mosfets is good because it speeds up the module. This could be a very good implementation if they made that simple change.
4b8255dace3ccdde0c5c87043c4f5651 ; 114 ; 24 ; 96 ; 21 ; We know that we need to use cascading XOR gates to compute S. Instead of figuring out how to compute S and Cout independently, we can combine the logic to reduce the number of mosfets used in the module. While independently using the XOR of A and B may not lead to the best way to compute Cout on its own, it is very effective in this case because it is essentially free to use the XOR of A and B tht we will already be computing.
3d7fdd43178c9c6d7de5618d78d66300 ; 114 ; 24 ; 126 ; 27 ; Using Demorgan's law, you can simplify the circuit for Cout using three 2-input NAND gates and a single 3-input NAND gate.
3d7fdd43178c9c6d7de5618d78d66300 ; 114 ; 24 ; 96 ; 21 ; Instead of separating the circuits for S and Cout, think about how you could use parts of outputs of gates from the S and Cout sections to save gates.
82339ab0f45ef0a80cd5077875b93e78 ; 114 ; 24 ; 126 ; 27 ; Try looking at the truth table and writing out the minimum sum of products from there. Remember that negative logic gates (e.g. NAND and NOR) use fewer mosfets than positive gates (like AND or OR).
82339ab0f45ef0a80cd5077875b93e78 ; 114 ; 24 ; 96 ; 21 ; Try to implement both outputs in the same circuit. This way you can avoid duplicating gates when it's unnecessary. 
657555e116629b7a08f64843742f399c ; 114 ; 24 ; 126 ; 27 ; You can reduce the size of your Cout module by constructing it using only NAND gates, since they can be made more efficiently in CMOS. Try developing a 3-input NAND first, and then using that as part of your solution.
657555e116629b7a08f64843742f399c ; 114 ; 24 ; 96 ; 21 ; In your solution, S and Cout are calculated completely separately. Think about reducing the size of your circuit by sharing some of the logic between the two circuits -- some of it is reusable.
d77614076eb9a4352df49a3afc89f9db ; 114 ; 24 ; 126 ; 27 ; The S is fine, but Xor's are large, so if you're not going to use a tree of smaller Nands to compute the Cout bit, you should at least not compute the Xor of A and B twice! Do it one, and use the results of A Xor B for both computing the rest of S and the rest of Cout. Yay, gate-sharing! :)
d77614076eb9a4352df49a3afc89f9db ; 114 ; 24 ; 96 ; 21 ; First of all, from DeMorgan's, we know that a "Nand of Nands" is functionally equivalent to an "Or of Ands." The Cout isn't just a tree of Nands in this case. It's a smaller tree of Nands, taking advantage of the fact that the Xor of A and B was already computed by a gate in the Sum bit logic. Following the "Or of Ands" interpretation of the "Nand of Nands", Cout is high when A and B are both high (bottom most gate). When A and B are not both high, but one of them is, the Xor of A and B is high. Mentally "anding" that output of the Xor with the Cin bit gives us the other part of the Cout term. Big win: we've shared a gate (the A Xor B) to save gates.
2dc6d81ee50f706ed8bc11e8e125dfae ; 114 ; 24 ; 126 ; 27 ; Try to reduce the propagation delay by reducing the number of cascading gates.
2dc6d81ee50f706ed8bc11e8e125dfae ; 114 ; 24 ; 96 ; 21 ; Instead of recalculating values, save computation results to save time!
46b480ea7af99d74f964a55f655d7ae9 ; 114 ; 24 ; 126 ; 27 ; S looks good.     Cout can be implemented more efficiently using negative logic: Instead of using    NAND3( NAND(A,B), NAND( XOR(A,B) , Cin) )    use:    NAND3(NAND(A,B),NAND(B,C),NAND(C,A))
46b480ea7af99d74f964a55f655d7ae9 ; 114 ; 24 ; 96 ; 21 ; This is good but not great. Use the equivalence from Comparison #1 to do get Cout more efficiently.
390d19373ca1214a61556e9833e39743 ; 118 ; 25 ; example=expected ; example=expected ; Split the problem up and use the simplest gates possible. Think simple for the carry logic. Nand's and Xor's are your friend. 
390d19373ca1214a61556e9833e39743 ; 118 ; 25 ; 96 ; 21 ; This one is hard. You know that at some point, you probably would like to xor a and b. That output can be used to find the carry. Nand's and xors are your friend.
4ce341e0d11bfb7c9023975b63359180 ; 114 ; 24 ; 126 ; 27 ; Don't use an XOR2 gate to compute Cout as XOR2 requires 10 mosfets. Instead, use 3 NAND2 gates with a NAND3 gate.
4ce341e0d11bfb7c9023975b63359180 ; 114 ; 24 ; 96 ; 21 ; Achieve efficiency in your circuit by using Cin and XOR2 of A, B in both the S and the Cout circuits. By employing this method, you can use only 3 NAND2 gates to compute Cout.
26afa3673e1a2f2b107c8ef480196afd ; 114 ; 24 ; 126 ; 27 ; I would ask if they could implement the Cout circuit without an XOR gate because XOR gates use many mosfets. I'd nudge them in the direction of using DeMorgan's Laws to manipulate the Cout expression and see that it requires only 4 NAND gates.
26afa3673e1a2f2b107c8ef480196afd ; 114 ; 24 ; 96 ; 21 ; I would suggest manipulating the expressions for S and Cout to see if there are common terms, so that the two output circuits could be combined to use less mosfets.
83faef0a662381f70354e97586fb74d4 ; 114 ; 24 ; 126 ; 27 ; Consider the trade off in number of mosfets between NAND gates and XOR gates.
83faef0a662381f70354e97586fb74d4 ; 114 ; 24 ; 96 ; 21 ; Think about how you could combine upstream gates for your two outputs instead of computing each output in parallel.
a3fd125e15795159a88939ca2605486e ; 114 ; 24 ; 126 ; 27 ; Simplify Cout using Demorgan's laws to make it a NAND or NANDs as opposed to using an XOR Gate. This would reduce the total number og gates
a3fd125e15795159a88939ca2605486e ; 114 ; 24 ; 96 ; 21 ; Since the XOR of A and B is used in Cout and S there is no need to create 2 Xors instead you can feed the output of one XOR of A and B to both S and Cout.
390caed60bcdb1649315cb8637415f8e ; 114 ; 24 ; 132 ; 33 ; Note that there is a way to reduce the circuit even further (hint).
390caed60bcdb1649315cb8637415f8e ; 114 ; 24 ; 96 ; 21 ; It is possible to simplify circuits to such a degree by taking note of the sum of products and using DeMorgan's law to simplify the circuit as much as possible, thus using less mosfets.
3859af17122343483d559b82d1086e2e ; 114 ; 24 ; 132 ; 33 ; You should use three 2-input NAND gates and one 3-input NAND gate instead of an AND an an OR. In general, it is best to use NAND and NOR gates because they have two mosfets fewer than AND and OR gates.
3859af17122343483d559b82d1086e2e ; 114 ; 24 ; 96 ; 21 ; You should factor out a C from the logical expression AB + BC + CA by noticing that if A and B are not both true, then CB + CA = C XOR(B, A). This allows you to reuse one XOR gate in the FA.
41e56bd3ab12a092588bd1a9dc89fa1b ; 114 ; 30 ; 144 ; 36 ; There is some redundancy in their current setup, and there are outputs that can be used for multiple inputs, thus saving valuables mosfets. For instance, the output of the A-B Xor gate in the S set up can be reused if they changed their set up for Cout accordingly.
41e56bd3ab12a092588bd1a9dc89fa1b ; 114 ; 30 ; 96 ; 21 ; There are equivalent logic equations that require a lower number of mosfets. By looking back at the work done and finding terms that can be exchanged for their less mosfet demanding counterparts one is able to lower the needed number of mosfets for their set up.
0c04563c899047e508675f2b6d284bdb ; 114 ; 24 ; 144 ; 36 ; I would suggest that they use 3 2 input NAND gates and 1 3 input NAND gate for Cout.
0c04563c899047e508675f2b6d284bdb ; 114 ; 24 ; 96 ; 21 ; I would tell them that it is beneficial to use the XOR gate for AB for both outputs S and Cout to reduce the number of Mosfets.
3cd6d3316ee8977fa9a7cfdf503850ee ; 114 ; 24 ; 144 ; 36 ; Consider that you can use 2- and 3-input NAND gates to replace the logic of the Cout logic. NAND is simpler to implement using CMOS and uses fewer fets. A cascade of NANDs is logically equivalent to the ANDs and ORs.
3cd6d3316ee8977fa9a7cfdf503850ee ; 114 ; 24 ; 96 ; 21 ; Cout should only be 1 when all three inputs A, B, Cin are 0. Consider using some of the information produced in processing the value of S to make computing Cout simpler. How can you reduce the number of gates used in computing Cout?
810d160ffa3f7d8ccc3433b3bc88793e ; 120 ; 30 ; example=expected ; example=expected ; Try not to combine the inputs so much because you might end up requiring more inverters to create more complex systems (I manipulated the formula given for Cout and that made me use more mosfets) 
810d160ffa3f7d8ccc3433b3bc88793e ; 120 ; 30 ; 96 ; 21 ; Do not think of S and Cout as two separate circuits, try to combine them, so that the work you had to do for part of S does not have to be done again for Co
b87905d2d5aa3d69fc46e36e01610f33 ; 114 ; 24 ; 144 ; 36 ; Use karnaugh maps to get minimum sum of products. It makes the design way easier.
b87905d2d5aa3d69fc46e36e01610f33 ; 114 ; 24 ; 96 ; 21 ; Consider S and Cout as coexisting outputs that share inputs, not as 2 separate outputs with separate inputs.
29a2363fc1ab737aa94e65aec4e0c475 ; 114 ; 24 ; 144 ; 36 ; First find the minimal sum of products for Cout, then devise a circuit using only NAND's, instead of AND's and OR's. You may also try designing some custom gates so as to use even less mosfets, for example, a custom 3 input NAND gate can save 2 mosfets from a 2 NAND implementation.     
29a2363fc1ab737aa94e65aec4e0c475 ; 114 ; 24 ; 96 ; 21 ; You've implemented two separate circuits, you could try to combine them in an effort to use less mosfets, for example, A and B are being NORed on the S circuit, you could use this result and implement the Cout circuit around it.
582bb342bb4cb1cb41d18b55d9188d42 ; 114 ; 24 ; 144 ; 36 ; Reuse the common computation for Sum and Carry-Out
582bb342bb4cb1cb41d18b55d9188d42 ; 114 ; 24 ; 96 ; 21 ; Use propagate &amp; generate logic
27617d27802a9dea61e1b981f7033283 ; 126 ; 30 ; example=expected ; example=expected ; First when implementing the XOR, you can cut down on the number of mosfets by implementing 2-input NANDs. Second, an AND-OR logic gate is equivalent to an NAND-NAND gate, but it uses less mosfets due to DeMorgan's Law and they are naturally inverters.
27617d27802a9dea61e1b981f7033283 ; 126 ; 30 ; 96 ; 21 ; You can take the output of one subsection of the logic gate and use it as an input for another subsection in order not to repeat logic gates.
aa59e556ee1fea466a556cf5fa66e961 ; 126 ; 30 ; example=expected ; example=expected ; Read the hints provided by the lab. I think that I would have implemented this better had I used the hints more readily.
aa59e556ee1fea466a556cf5fa66e961 ; 126 ; 30 ; 96 ; 21 ; Attempt to tied the circuits together so that you don't have to use the same piece of a circuit more than once independently.
a44f247d49f37e6180260d863c33a41f ; 114 ; 24 ; 132 ; 36 ; I would point them to the section of the lab that advises us to use three 2-input NANDs and one 3-input NAND for the implementation of Cout.
a44f247d49f37e6180260d863c33a41f ; 114 ; 24 ; 96 ; 21 ; I would tell them to see how they can use the the output of the first XOR gate in the S implementation as an input to the gates they use for the Cout implementation to decrease the number of gates they use and thus the number of mosfets. 
d2b89cd5a50f48b8d18a684050513a82 ; 126 ; 30 ; example=expected ; example=expected ; Wait, I thought this is exactly what I did.
d2b89cd5a50f48b8d18a684050513a82 ; 126 ; 30 ; 96 ; 21 ; Think in terms of modules!
990d1ded4a2d50b5afeb24a72d645acc ; 114 ; 24 ; 132 ; 36 ; Try avoid using AND,OR. Those components require at least 2 more MOSFET than NAND,NOR would.
990d1ded4a2d50b5afeb24a72d645acc ; 114 ; 24 ; 96 ; 21 ; Try conserving the amount of times you are generating the same output. Something created in one part of the circuit can be funneled to another. 
a0069c9dc51bf8c3f266ae6dc619198f ; 114 ; 24 ; 132 ; 36 ; Your logic gates for your S output seem fine. We can work on the logic gates for Cout. We have a XOR that takes A and B inputs and gives out a O1 to say. The AND gate takes in that O1 and a C1 and outputs O2. Then we have another AND gate that takes in A and B and outputs O3. Your final XOR gate takes in that O2 and O3 to give Cout. This means my longest path is 3. We want to make our longest path shorter. What we can do is instead of having XORS and AND gates, we can implement 3 2-input NAND gates and 1 3-input NAND gate. By doing this we shorten our longest path to 2.
a0069c9dc51bf8c3f266ae6dc619198f ; 114 ; 24 ; 96 ; 21 ; Instead of thinking about components individually why not try to reuse gates. By reusing gates, we can make use less MOSFETs which means that the propagation delay will be minimal because we don't have to use the 3-input NAND gate to obtain Cout. We do that process in earlier steps using this design.
9afab6d3589a9ad65c8f91623d066a5b ; 114 ; 24 ; 132 ; 36 ; For Cout, Instead of using OR and AND gates, we can use the 3 NAND2 and 1 NAND3 gates like described in the lab. which would reduce the number of mosfets because we can use 4 mosfets for each NAND2 gate but each AND and OR requre 6. 
9afab6d3589a9ad65c8f91623d066a5b ; 114 ; 24 ; 96 ; 21 ; Instead of separately doing S and Cout, consider taking one of the outputs already computed and combining, to decrease the number of mosfets. Here, for instance, we can use the output from A XOR B in the NAND gate with Cin. This reduces the number of mosfets we need by making use more effectively of gates we're already using. 
30f11517f7256d7fb9a150981f8021f3 ; 114 ; 24 ; 132 ; 36 ; I would advise to think of a way to have one set up instead of two, so that S and Cout can be found together.
30f11517f7256d7fb9a150981f8021f3 ; 114 ; 24 ; 96 ; 21 ; I would advise the design to be changed so that there are more negative gates, which would allow there to be fewer MOSFETs used.
818947bc0fdb03e3998b5811af07ad48 ; 126 ; 30 ; example=expected ; example=expected ; Use more basic elements (pfats and nfats) and fewer logic gates. Try to use as few mosfets as possible.
818947bc0fdb03e3998b5811af07ad48 ; 126 ; 30 ; 96 ; 21 ; Reuse the results that you have already calculated instead of calculating them again.
481ed88ee2fdca042597af902d45ad2d ; 114 ; 24 ; 150 ; 42 ; In stead of using AND and OR gates for Cout - you can use NAND gates to create the same logic with less mosfets.
481ed88ee2fdca042597af902d45ad2d ; 114 ; 24 ; 96 ; 21 ; You can reduce the number of gates, but using the results of the first A/B XOR gates and feeding that into a NAND gate, thereby reducing by one 3 input NAND gate. 
0a16bc32f55683128983f223de242942 ; 114 ; 24 ; 150 ; 42 ; Cascaded and and or gates are equivalent to nand gates (in this case, three 2-input nand gates and one 3-input nand gate).
0a16bc32f55683128983f223de242942 ; 114 ; 24 ; 96 ; 21 ; S and Cin don't need to be calculated separately - they can share some gates. Specifically, since calculating S requires 2 XOR gates, the output of the first one can be used to simplify the calculation of Cout.        Cout = [A nand B] nand [Cin nand (A XOR B)]
f2f2f47f264f7ffe875250d1fc76afea ; 114 ; 24 ; 150 ; 42 ; The cout calculation is inefficient. It would be smart to find a way to possibly combine the the or gates into one. Also, embedded in each AND and OR gate is an inverter. This is because CMOS is naturally inverting, so you should be able to use the simpler NOR or NAND gates to reduce the number of mosfets.
f2f2f47f264f7ffe875250d1fc76afea ; 114 ; 24 ; 96 ; 21 ; Consider taking the computation for the carry bit and combine it with the computation used for the S output. This can potentially make the calculation more efficient.
540617bf672b559cf8dacedd9af401c5 ; 114 ; 24 ; 150 ; 42 ; There's no reason to ignore the fact that MOSFET gates are inverting - run with it when you can, by using NAND and NOR, not AND and OR.
540617bf672b559cf8dacedd9af401c5 ; 114 ; 24 ; 96 ; 21 ; It isn't necessary to ignore the work you've done in intermediate steps, you can use every sub result you've computed, such as the XOR gate reuse at right.
8a0aec95994d0ed20ad440bce49e04c4 ; 114 ; 24 ; 126 ; 27 ; You can reuse the outputs of the A xor B to save mosfets.
8a0aec95994d0ed20ad440bce49e04c4 ; 114 ; 24 ; 96 ; 21 ; Think about reusing inputs more and think about how you can convert between logic functions to reduce the number of mosfets.
7638bbbaea0b6589a2100116a726fe6c ; 114 ; 30 ; 126 ; 27 ; Look at where you're duplicating logic. There's an easy way to reduce mosfets used. 
7638bbbaea0b6589a2100116a726fe6c ; 114 ; 30 ; 96 ; 21 ; Good work! Now make it better by perhaps drawing truth tables and looking where you have high level repeats of previously computed logic. Perhaps carry forward previous logic?
f6a91d59b97eb0683a062e15250810b0 ; 114 ; 24 ; 126 ; 27 ; Use more inverting logic! The xor takes a bazillion MOSFETs to implement; we can implement this instead using only NANDs, which take only 4 FETs each--and also a 3-input NAND which takes 6 FETs.
f6a91d59b97eb0683a062e15250810b0 ; 114 ; 24 ; 96 ; 21 ; Don't consider the outputs (S and Cout) to be "separate" entities in separate systems. By doing that, you miss out on possibilities of combining inputs and/or logic gates. In this case, we can use the output of the XOR2 (that takes input A and B and helps in the computation of S) and feed it into gates to help compute Cout.
5fc05a7ec803489fd94b256c43b239ce ; 132 ; 30 ; example=expected ; example=expected ; I would tell them to try to describe each output as a simple 2- or 3- input logic function, and build a separate circuit for each one. This is a far better approach than I originally took of creating gates made out of gates made out of gates, to the point that my original submission took longer than the allotted time.
5fc05a7ec803489fd94b256c43b239ce ; 132 ; 30 ; 96 ; 21 ; I would mention the same things I wrote in the previous questions, except in this case, I would tell them that rather than make two separate logic functions (a 2-input and a 3-input, each with one output), that they could combine the two into a single logic function with 3-inputs and 2 outputs.
133e3b26ca5cc7d7ba72bbcb437602e0 ; 114 ; 24 ; 126 ; 27 ; Use less xors and more nands
133e3b26ca5cc7d7ba72bbcb437602e0 ; 114 ; 24 ; 96 ; 21 ; feed the nands into each other instead of using 4 of them
ba46c533e060ca97d3bda49df8e9b9ba ; 114 ; 24 ; 126 ; 27 ; I would tell them to reconsider how they designed their solution for Cout, specifically the XOR logical gate in the Cout circuit. I would remind them that XOR takes a lot of mosfets to build, and ask them if they can think of more ways to use other logical gates instead of XOR.
ba46c533e060ca97d3bda49df8e9b9ba ; 114 ; 24 ; 96 ; 21 ; I would tell the them to write the logical output of each of their logical gates, and tell them to try and see if any of them matched up (or could potentially match up) with the input into a different logical gate; this way, it would be easier to see that the XOR that is involved in outputting S can be connected to the NAND2 involved in outputting Cout.
c9913b048859c45f783f8659e845ca07 ; 114 ; 24 ; 126 ; 27 ; XOR takes 10 fets, which is a lot. See if you can avoid using that XOR in your Cout circuit. Write it out as a logic equation (like A or B and B or C etc...) and try to find a way to use only NANDs.
c9913b048859c45f783f8659e845ca07 ; 114 ; 24 ; 96 ; 21 ; It's a good start to do you S circuit and then your Cout circuit, but you should try and see if there is a way to reuse gates by combining these circuits. 
57f42870c661501f90017c55deaca572 ; 114 ; 24 ; 96 ; 21 ; Think about how you can use the output from your XOR gates to help you get Cout, to eliminate some redundancy.
9fb11c0b07b64233773686fa3274e4cd ; 114 ; 27 ; 126 ; 27 ; The adder is identical. I would tell them to keep in mind that a XOR is 10 mosfets using the design given in the lab, and that there is a way to switch out that subcircuit for one that uses less mosfets, yet does not change the output of the entire circuit.        (The solution of course is to change the XOR to an OR)
9fb11c0b07b64233773686fa3274e4cd ; 114 ; 27 ; 96 ; 21 ; I would tell them to keep in mind that in the calculation of the sum, they already computed several logic functions, and that they should keep in mind that they can use those functions as inputs as part of the "separate" carry bit circuit.
129b528ce67889022ee952d939b5e9d4 ; 114 ; 24 ; 126 ; 27 ; Develop a three input NAND gate to reduce a level of cascading and to reduce the number of MOSFETs used on the MOSFET level as opposed to the gate level.
129b528ce67889022ee952d939b5e9d4 ; 114 ; 24 ; 96 ; 21 ; Try using the intermediate output of the calculations for S in calculating Cout instead of separating the two calculations to save on the number of operations required.
5a0dc00ad159824360ae0a85907bbc6e ; 96 ; 21 ; 126 ; 27 ; Computing XOR is expensive. Are there any gates that are repeating operations and can be removed?
3fc768dad95b4c0bb76a63281c8966b3 ; 150 ; 42 ; example=expected ; example=expected ; This was my design, I think that the difference lies in my gate implementation (my xor was expensive). Make sure your gates are optimized as if they are not it will cost you. 
3fc768dad95b4c0bb76a63281c8966b3 ; 150 ; 42 ; 96 ; 21 ; I wouldn't call this a better solution, as the circuit is slower. To quote the assignment, "minimize the tPD of the logic that computes Cout."        To achieve such results, I would advise looking at what transformations you can do on your boolean logic to make it contain something you have already computed.
1686f60b33f7ca2d23dceca09774ca42 ; 114 ; 24 ; 126 ; 27 ; Try to use universal gates whenever possible, a NAND gate would use less mosfets in the lower circuitry.
1686f60b33f7ca2d23dceca09774ca42 ; 114 ; 24 ; 96 ; 21 ; Think about reusing circuitry used to calculate one output to calculate the other output.
a56fff35cbfa3e9c3ef59cb2429d3699 ; 114 ; 24 ; 126 ; 27 ; Using and xor gate adds 4 mosfets per single-bit full adder. Is there any other way to implement the truth table for Cout such that we can reduce the number of mosfets used per full-adder by four mosfets.        Answer: (Using a nand3 with the inputs of three nand2s results in the proper output for Cout with a difference of four mosfets per full adder, summing to a difference of 12 mosfets. So, to set this up one must simple input the three variables into the nand2s for out1: (nand2(A,B)), out2: (nand2(A, Cin)) out3: (nand2(B, Cin)), and input the three outs into a nand3 gate.)
a56fff35cbfa3e9c3ef59cb2429d3699 ; 114 ; 24 ; 96 ; 21 ; Cout can also be implemented using xor2 gates and some nand2 gates, however if you compute Cout and S separately, this results in a larger number of mosfets than what you have here. Can you think of a way to form Cout using a xor2 gate and some nand2 gates. (Answer as in comparison #1) Alright, now can you explain how to hook this up to internal nodes in the computation of S to reduce the number of mosfets per full adder model by 6 (leading to a total reduction of 18 mosfets over the three-bit adder).
12d1427a14bf4b60224fd1a3fb7fd686 ; 114 ; 24 ; 126 ; 27 ; To decrease the number of mosfets to calculate Cout, the student can create a three-input NAND gate and take in the three two-input NAND gates. This decreases the number of mosfets used because the XOR gate uses more mosfets than a three-input NAND gate would.
12d1427a14bf4b60224fd1a3fb7fd686 ; 114 ; 24 ; 96 ; 21 ; Instead of making a three-input NAND gate, the Cout result can be created by using three two-input NAND gates with one of them taking in the inputs XOR of A and B and Cin. The output from the XOR gate used when calculating s can then be reused as an input for the NAND gate that takes in XOR of A and B and Cin. This reuse of outputs decreases the number of mosfets needed.
eefd0f0f508ef86f7a379cb8fb06fa52 ; 114 ; 24 ; 126 ; 27 ; Look at the number of MOSFETS present in a NAND2 versus a XOR2 gate.  XOR2s are much more expensive, so how could you complete the Cout calculation without using one?  If it helps, consider checking the number of MOSFETS present in a NAND3 gate.
eefd0f0f508ef86f7a379cb8fb06fa52 ; 114 ; 24 ; 96 ; 21 ; Notice that you're already computing XOR(A, B) to find their binary sum.  Since you already have that sum, how can you use that in your calculation of Cout to make it cheaper?  How would you calculate Cout only using three gates, none of which are a NAND3?
a37661d9f649290d5f621ecb171c0837 ; 90 ; 28 ; 126 ; 27 ; The Cout chain needs to be optimized, like the lab has stated. Chaining 2 of the same gate to accommodate 3 input will hurt the final schematic, just make 1 gate with 1 or more additional inputs. 
432a9b7e8ae2eb5261c8fc5320d339b8 ; 114 ; 30 ; 126 ; 27 ; You have two or more gates that accomplish the same thing. Specifically, two gates compute A nor B. Remove one of these gates to lower your mosfet count.
432a9b7e8ae2eb5261c8fc5320d339b8 ; 114 ; 30 ; 96 ; 21 ; You're probably not simplifying the logic as much as you can and using superfluous gates as a result. I used far too many inverters in my first solution, and you can cut down on your mosfet usage by trying to use less.
f85907121d219fc7e739d7a610c7e3ed ; 96 ; 18 ; 126 ; 27 ; Remember that all cmos gates can be implemented as a nand-nand circuit via sum of products. When this is not checkerboard pattern on the k-maps, this can be easily simplified into even fewer mosfets. Try to implement Cout in this way.
96d83eb58a7bf18f7ec8c5b7e9f465ec ; 114 ; 24 ; 132 ; 33 ; You can reduce the number of mosfets used by defining a 3-input NAND gate
96d83eb58a7bf18f7ec8c5b7e9f465ec ; 114 ; 24 ; 96 ; 21 ; Integrate the subcircuit for the S output with the subcircuit for Cout instead of having two separate subcircuits
9dfc87e035a1b38fa2f0276cbe6c79a7 ; 126 ; 30 ; example=expected ; example=expected ; Think about which logic gates naturally need less MOSFETS - can you make an arrangement using these low-MOSFET count logic gates that will do the same operation as your module here?    
9dfc87e035a1b38fa2f0276cbe6c79a7 ; 126 ; 30 ; 96 ; 21 ; Can the output of any of your logic gates serve as an input for another logic gate? Do S and Cout really need to be calculated separately? Can you use this to eliminate any of your current logic gates?
86bdd4b7c36e2fa49d1f2e91325c5a90 ; 114 ; 24 ; 132 ; 33 ; instead of using and AND gate and an OR gate (and thus needing an extra NAND gate to make the outputs from A NAND B and A NAND Cin positive, just use a NAND gate for B AND Cin and then you only need a NOR gate to invert the answer and get the positive solution
86bdd4b7c36e2fa49d1f2e91325c5a90 ; 114 ; 24 ; 96 ; 21 ; Instead of keeping the combinational gate for S and for Cout separate, think of a way that can combine the two together. So, instead of using 3 NAND gates for each of the three parts making up C0, think of a way of combining those 3 parts to create two so that one takes advantage of the XOR gate that is already needed to output S (see that A*Cin + B*Cin = Cin * (A + B))
51cdcf356a513a7636df8935df8e314a ; 96 ; 21 ; 132 ; 33 ; You are using two separate chains of computation, one to figure out S and another to figure out Cout. These might not look like it, but they are duplicating work. Try to figure out a way to combine them and get rid of your AND and OR gates.
a8b04808eacb0a1b1af1d50d15823d5f ; 114 ; 24 ; 132 ; 33 ; How can you condense the Logic operators for calculating Cout to use fewer mosfets? Perhaps use something that takes 3 inputs.
a8b04808eacb0a1b1af1d50d15823d5f ; 114 ; 24 ; 96 ; 21 ; Is there overlap between the diagrams for Cout and S you drew? How can you use an output from one to feed into another?
ffdaa295b51d3c542843c8e145a3a6da ; 114 ; 24 ; 132 ; 33 ; I would tell them that they should focus on using NAND gates instead of AND/OR gates. They should know the equivalence of two cascading NAND gates and how it relates to the logic equation from DeMorgan's Law. 
ffdaa295b51d3c542843c8e145a3a6da ; 114 ; 24 ; 96 ; 21 ; I would tell them to make use of the outputs of one subcircuit and incorporate it into the other. This increases the efficiency of the circuit.
be1eb5bb96c31cd19f2cbf50562031d0 ; 114 ; 24 ; 132 ; 33 ; Use a 3-input NAND gate rather than computing (A NAND B) NAND (A NAND C_in)
be1eb5bb96c31cd19f2cbf50562031d0 ; 114 ; 24 ; 96 ; 21 ; By checking truth tables, it is easy to see that NAND(A NAND B, A NAND C_i, B NAND C_in) = (A NAND B) NAND (C_in NAND (A XOR B)), and the latter is cheaper to implement in this case because we have already computed A XOR B in the upper half of the computation!
dae1a3eea8990f4e204feb2d8e5d1275 ; 114 ; 24 ; 132 ; 33 ; I would advise them to use a 3-input NAND gate with three 2-input NANDs.
dae1a3eea8990f4e204feb2d8e5d1275 ; 114 ; 24 ; 96 ; 21 ; I would advise them to consider using the intermediate outputs from the S circuit as inputs to finding Cout.
83de5046fc7337232d3a34742e4f24f0 ; 114 ; 24 ; 132 ; 33 ; Calculate Cout by using three two-input NANDs that cascade into one three-input NAND.
83de5046fc7337232d3a34742e4f24f0 ; 114 ; 24 ; 96 ; 21 ; You can use calculations for finding S to help you find Cout rather than having them be totally separate circuits. 
c9b728bbbac28cc9f74ff8cf9b4b2fae ; 104 ; 26 ; 132 ; 33 ; My design for S portion is the same.         The design for C differs. Instead of using 3 Nand gates, 1 nand gate and 1 xor, I made this part of the problem out of two Cmos Gates.         1st gate: NOT(AB + CA + CB)    2nd gate: Inverter
c9b728bbbac28cc9f74ff8cf9b4b2fae ; 104 ; 26 ; 96 ; 21 ; I used the same tactic for the S portion of the FA problem.        However, this person made use of a common XOR gate for S and Cout. I separated the two problems entirely, which yielded the extra 8 mosfets in the process. My XOR had 8 mosfets, so had I used it twice for the purpose of both - S and Cout, I would have had a more efficient design. 
e76c66091b9909d4ace15d916587705c ; 114 ; 24 ; 132 ; 33 ; ANDs and ORs are expensive in CMOS circuits -- an AND is actually an INV after a NAND and an OR is an INV after a NOR. It's also important to note that NANDs and NORs are "cheap" and that adding one more input to them simply adds two more mosfets.        This is motivation to look at whether we could use only NAND/NORs to build the Cout circuit. We note that by appyling de Morgan's law to the expression NOT(NOT(A AND B) AND NOT(A AND Cin) AND NOT(B AND Cin)), which is also NAND(NAND(A, B), NAND(A, Cin), NAND(B, Cin)), we get OR(AND(A, B), AND(A, Cin), AND(B, Cin)). So we could build Cin using just NANDs! Instead of 3 NAND2s, one AND2 and one OR2, we can have 3 NAND2s and one NAND3.        (I'm not sure how the difference is 18 mosfets though, I get that the difference is 4 mosfets... Perhaps their XOR implementation is different?).
e76c66091b9909d4ace15d916587705c ; 114 ; 24 ; 96 ; 21 ; We note that Cout = A*B + A*Cin + B*Cin can be re-written as Cout = A*B + Cin*(A + B). Then we note that this is equivalent to Cout = A * B + Cin*(A XOR B) because XOR follows OR except for the 1, 1 case, where XOR is false but OR is true. But if A = B = 1, A*B will be true and produce the correct Cout! Drawing out the truth table will help see the equivalence. This means that we can reduce the circuit further, because we've already calculated A XOR B for S so can re-use this result. Using NANDs instead of ORs/ANDs follows from de Morgan's laws, which the student already used in their circuit.
d936395bca925636399745c1b37a1b79 ; 126 ; 30 ; example=expected ; example=expected ; You can define a 3-input NAND gate instead of cascading two 2-input NAND gates.
d936395bca925636399745c1b37a1b79 ; 126 ; 30 ; 96 ; 21 ; You can simplify your solution by using three 2-input NAND gates by reusing the outputs from your XOR gates.
d0c79a262a3488589762ed5b3b75b90b ; 162 ; 34 ; example=expected ; example=expected ; At a gate level, my Full Adder circuit is identical to the solution pictured above. The advice given in the lab prompt clearly steered students in this direction.
d0c79a262a3488589762ed5b3b75b90b ; 162 ; 34 ; 96 ; 21 ; I would encourage students to find ways to reuse gate outputs for more than one computation, just as the output of A XOR B is used in the solution above.
106123eddb076a9f0a655a9ec2454176 ; 96 ; 21 ; 144 ; 36 ; One thing to do to improve the design is to replace some cascades (e.g. AND-OR) for NAND cascades. Another thing is to connect the two circuits, that way, it is possible to reuse part of the design to get both outputs, therefore reducing the overall number os mosfets.
665dc1373bffad4b7795528169b975c0 ; 114 ; 24 ; 144 ; 36 ; Try to find a more efficient way to implement Cout.  Use NANDs and NORs instead of ANDs and ORs and XORs wherever possible, since they require fewer mosfets.  
665dc1373bffad4b7795528169b975c0 ; 114 ; 24 ; 96 ; 21 ; Try to reduce redundancy in your solution by finding common patterns in S and Cout and combining them where possible.  
08ec5e7ee2d32a2c0ce49d55842619ee ; 114 ; 24 ; 144 ; 36 ; I would advise them against using NOR gates for the finding of C(out) because 10 mosfets are used in each NOR gate, and 6 for each of the AND gates. If they had used NAND gates instead, then each of the NAND gates would only use 4 mosfets and the total number of mosfets used would decrease. 
08ec5e7ee2d32a2c0ce49d55842619ee ; 114 ; 24 ; 96 ; 21 ; I would remind them that because of Demorgan's law, they could simplify their logic by replacing some of the NAND gates with NOR gates, and then that they already implemented some NOR gates whose outputs they could reuse.
e8b1eb6efd9bee20cbfab7927c436d91 ; 114 ; 24 ; 144 ; 36 ; You can use NANDs to make the Cout, one of which is a 3-input NAND which is more efficient.
e8b1eb6efd9bee20cbfab7927c436d91 ; 114 ; 24 ; 96 ; 21 ; You do not have to make the S and Cout separately. You can use the output AXORB for S in your circuitry for Cout
387332c3b8e6e59e4875d274d30cd66e ; 96 ; 21 ; 144 ; 36 ; The first thing I would suggest is to integrate the circuits for S and Cout. The XOR in the second circuit can be replaced by the leftmost XOR gate in the S circuit. We can then route this output to the AND gate. This eliminates one XOR gate (which contains quite a few mosfets). Because NAND gates are the preferred in the implementation of this adder, we can then replace the AND/OR gates as NAND gates by Demorgan's Law. 
a86760c8437849745cc669816cdf68a2 ; 114 ; 24 ; 144 ; 36 ; Consider using DeMorgan's Laws to transform the Cout logic into a set of NANDs.
a86760c8437849745cc669816cdf68a2 ; 114 ; 24 ; 96 ; 21 ; Rather than implementing the logic for S and Cout as totally distinct circuits, is there a way that you could use an intermediate output from one as an intermediate input in the other?
1036759aa975555600fa944e15d0584f ; 114 ; 30 ; 144 ; 36 ; Get rid of the bottom XOR gate and connect the inputs differently
1036759aa975555600fa944e15d0584f ; 114 ; 30 ; 96 ; 21 ; Replace the  two AND gates and OR gate with two NAND gates
d1dc87369c1aac2db87a95d16ef4dd8a ; 114 ; 24 ; 132 ; 36 ; Use inverting logic (NAND gates) for Cout
d1dc87369c1aac2db87a95d16ef4dd8a ; 114 ; 24 ; 96 ; 21 ; Combine logic for S and Cout
c6bd74c3c66a1ef39584080032126361 ; 168 ; 51 ; example=expected ; example=expected ; Use only XOR gates for your S output and only NAND gates for Cout but don't limit yourself to 2-input devices.
c6bd74c3c66a1ef39584080032126361 ; 168 ; 51 ; 96 ; 21 ; Try making one 2-output device rather than two 1-output devices.
1c99c5a7d118311c49b120be2118e44a ; 114 ; 24 ; 132 ; 36 ; Instead of using cascading AND/OR for the computation of Cout, consider using NAND. Two cascaded NANDs are logically equivalent to a cascade of AND/OR.
1c99c5a7d118311c49b120be2118e44a ; 114 ; 24 ; 96 ; 21 ; We can use the result of A xor B in order to eliminate a NAND gate in the computation of Cout.
3ea51325231bfc23fd2949f38b02d613 ; 96 ; 21 ; 132 ; 36 ; Look at the gate they're duplicating. They can combine the AND and OR into 2 cascaded NANDS and combine with the first A XOR B gate to end up with 3 NAND gates for Cout.
0138facdf58028465ea5d7ede55cbdb6 ; 90 ; 28 ; 132 ; 36 ; Try using NOR and NAND gates instead of OR and AND gates. Because CMOS gates naturally invert signals, OR and AND gates require an inverter at the end of a NAND or NOR circuit, so they have two more mosfets each. You can easily invert your logic to use NAND and NOR instead of AND and OR gates by remembering that (A) AND (B) = (NOT A) NOR (NOT B), and that (A) OR (B) = (NOT A) NAND (NOT B).
8cb1a0fd9578fda627dded85756e8702 ; 156 ; 48 ; example=expected ; example=expected ; So, one thing you didn't consider was having multiple-input Mosfets.  We know there are issues with speed when we have more mosfets, so there's no reason to cascade two adds when we can use one!  That decreases your MOSFET count by 14 Fets per Full Adder.  Realize though that XOR3 isn't as easy to implement, which is why we use the cascade for that here.
8cb1a0fd9578fda627dded85756e8702 ; 156 ; 48 ; 96 ; 21 ; This isn't quick to think of, but it makes a lot of sense.  We preserve the definition of S, and we not that AB+BC+CA is AB+(BC+CA) = AB+C(A+B).  Then we can use casework.  If A AND2 B are true, then the definition for Cout is True; otherwise, if Cout is true exactly one (XOR2) of them must be True, AND2 C must be true.        This is motivated by the desired to reuse what we have -- and the XOR representation is stuck, so if we use the low-noise margin output of the first XOR2, we may be able to avoid having to do a calculation to get a similar result.
aa9a7f5e4bcccf5ec25bea5f7e8492eb ; 114 ; 24 ; 132 ; 36 ; I would tell them to reconsider there Cout portion of their adder.  Because cmos is naturally inverting, it would be more efficient to use NORs and NANDs because your signal doesn't have to go through an inverter as well.
aa9a7f5e4bcccf5ec25bea5f7e8492eb ; 114 ; 24 ; 96 ; 21 ; I would tell them to try manipulating either the formula or the gates to try to reduce the number of gates.
2be7d7e09b2268200167ab05e219d46d ; 114 ; 24 ; 132 ; 36 ; To compute Cout, use NAND2's and a NAND3, which use far fewer mosfets than the ANDs and ORs.
2be7d7e09b2268200167ab05e219d46d ; 114 ; 24 ; 96 ; 21 ; Use the result of A XOR B to compute Cout with 3 NAND2's (instead of 3 NAND2's and a NAND3).
fd88f36c94a82467c60ba694d9c61773 ; 126 ; 30 ; example=expected ; example=expected ; My gate-level solution is the same as above, so I'd need to go through my/their gates.
fd88f36c94a82467c60ba694d9c61773 ; 126 ; 30 ; 96 ; 21 ; Use the intermediate step A XOR B from S in computing Cout by finding (A XOR B) NAND C instead of (A NAND C) NAND (B NAND C).
13f5675a9defb7a16b2e115e52191ab9 ; 114 ; 24 ; 132 ; 36 ; Simplify Cout by using inverting logic
13f5675a9defb7a16b2e115e52191ab9 ; 114 ; 24 ; 96 ; 21 ; Think about how you can reuse your gates to make things more efficient
f2bf56531d17dd7822c26b5cd8391aa4 ; 114 ; 24 ; 132 ; 36 ; Our designs to compute S are the same, but the design to tabulate Cout differs. It seems as though this student used AND and OR gates, but using NAND gates is much more efficient. By using DeMorgan's Law this circuit can be translated into the more efficient version using NAND gates.
f2bf56531d17dd7822c26b5cd8391aa4 ; 114 ; 24 ; 96 ; 21 ; I think their are alternatives to the internals of the XOR gate. These alternatives contain less than 10 MOSFETS. This would significantly decrease the number of gates from 114 to 96 mosfets.
bbccdc47e193cb291ef72abd58959e64 ; 138 ; 36 ; example=expected ; example=expected ; Good job getting the FA schematic right! Now all that is needed is to reduce the number of mosfets in the XOR gate.
bbccdc47e193cb291ef72abd58959e64 ; 138 ; 36 ; 96 ; 21 ; If any combination of inputs is used more than once, considering only calculating that combination once and using the result in future calculations. Also, reduce the XOR mosfet count.
d87178e208437cdb1c81615d3d4c9585 ; 114 ; 24 ; 132 ; 36 ; I would tell them to consider using NAND gates to calculate Cout instead of ANDs and ORs.
d87178e208437cdb1c81615d3d4c9585 ; 114 ; 24 ; 96 ; 21 ; I would tell them to try to think of a way to use fewer NAND gates by wiring XOR(A,B) (which they calculated while trying to find S) into one of the NAND gates.  Then I would tell them to see if they could think of a way to build the circuit without a three-input NAND gate.
1e83db1b88a4cdf4a803d09637b7283a ; 114 ; 24 ; 132 ; 36 ; When looking at the Cout outputs and the truth table, we can see that Cout can be given as     AB + BCin + ACin     But that's not so hard, so we can make 3 initial comparisons using the magical NAND2 and get three outputs. You had the right idea, but to decrease the number of MOSFETS, use less logic gates. Ok, that wasn't so bad right?     Now we just have to use use three OR statements to compare them so just... WAIT UP! Were you using NAND2 for comparisons? Good, then you listen well, but that also means we can't just walk on through with ORs because we were inverting the answer so far. So taking that into account, notice that we need one 3 input operator to compare the NANDS. What would that be? (Hint, it's another NAND. teehee)
1e83db1b88a4cdf4a803d09637b7283a ; 114 ; 24 ; 96 ; 21 ; Ok, here's the deeleeoh! According to the god of MOSFETS, there is a simpler way of solving this. The truth lies in the fact that AB + BCin + ACin  can bee seen as an algebraic system for simplicity. So, lets look at Cin(A + B) and lets compare this to the output from XOR2(A B)!    Using that XOR output, and the input from Cin, what logical operator can you use to make the equivalent to Cin(A + B)?     Now as your LA I will leave and you will scorn my name for not giving you the answer.
14ba1e28d148dd92884a8f199af62bbc ; 114 ; 24 ; 132 ; 36 ; You are not limited to just the fundamental 2 input gates we talked about in class.  Is there a device you could create on a MOSFET level that would limit your use of cascading gates?
14ba1e28d148dd92884a8f199af62bbc ; 114 ; 24 ; 96 ; 21 ; Think about the equation used to get Cout.  Is there someway we could simplify that equation, not necessarily just using AND/OR/NOT, and then implement that simplification in CMOS?  Can you think of a way to do this that makes use of the circuit you used to create your S output in order to save on total transistors used?
ea968c6638ea6a1bc0d856243164b3bc ; 114 ; 24 ; 132 ; 36 ; Think about a way to reduce the number of mosfets for Cout. Which logical gates use less mosfets than AND and OR gates? 
ea968c6638ea6a1bc0d856243164b3bc ; 114 ; 24 ; 96 ; 21 ; I have no advice. 
6e047ac9bd00ee0b936c1292cccaccb5 ; 114 ; 24 ; 150 ; 42 ; Try using 2-input and 3-input NAND gates to calculate Cout instead of using only 2-input AND and OR gates.
6e047ac9bd00ee0b936c1292cccaccb5 ; 114 ; 24 ; 96 ; 21 ; Try to use one of the intermediary stages in the calculation of S when calculating Cout so that you do not use multiple CMOS gates to calculate the same thing. 
88a985a041e2b0de80b36c44e88cd1fc ; 114 ; 24 ; 150 ; 42 ; I recommend that you take a look at the A,B,Cin input to Cout diagram where you used 3 ANDs and 2 ORs (this uses 30 mosfets x 3 = 90 mosfets total). Write out the logic expression for that part, and using the technique of inverting the expression twice, try to simplify the expression again using De Morgan's Law. This should help you to take the ANDs and ORs, and replace them with NANDs/NAND3s. NANDs take less mosfets to implement since they're inverting logic. This should help you cut down the design by 36 mosfets. 
88a985a041e2b0de80b36c44e88cd1fc ; 114 ; 24 ; 96 ; 21 ; I would tell the student to write out the logic expression for their design then see if they could rewrite the expression without using the NAND3. I would also advise that they look at the truth table for XORs and see if a part of their original logic expression could be substituted by an existing XOR. 
8a4eebaf9c96ed7acc65c10af479c948 ; 114 ; 24 ; 150 ; 42 ; You should replace your regular and's and or's with NANDS since NANDS require two less MOSFETS since CMOS gates are naturally inverting.  By using the NANDS of NANDS implementation, you achieve the same logic (Due to Demorgan's Law) while using less mosfets.
8a4eebaf9c96ed7acc65c10af479c948 ; 114 ; 24 ; 96 ; 21 ; By reusing the COR gate implemented in the S logic, we save a gate and thus use less mosfets in the implementation.        We can show using Demorgan's Law that a XOR2 + NAND2 of 2 NAND2's is equivalent logically with the previous NAND3 of 3 NAND2's.  This creates a more efficient circuit while achieving the same adder we are hoping to build.
7f0c5eff8508dbb9e3274396258a8da8 ; 114 ; 24 ; 150 ; 42 ; The implementation for the calculation of S is correct but there is an easier way to implement Cout. You have cascaded OR Gates conecting AND gates. Because AND-OR is equivalent to NAND-NAND you could implement this circut using less gates by using only NANDs. Instead, of 3ANDs and 2ORs this circut could be implemented using 3 2input NANDS and 1 3input NAND assembled in a similar configuration.
7f0c5eff8508dbb9e3274396258a8da8 ; 114 ; 24 ; 96 ; 21 ; Here the circuts for the S and Cout are interlinked to save mosfets. Think of a way in which Cout can be found using 3 NANDs and an XOR. Then that same XOR can be used to compute S
b0f3aead3bde16b88a1d6fe669d247b2 ; 114 ; 24 ; 150 ; 42 ; AND and OR gates are not inverting, meaning they will require more mosfets than naturally inverting gates. See if you can simplify the function with Demorgan's law to find a logically equivalent function that uses inverting logic. Hint: two cascaded NANDs are logically equivalent to a cascade of AND/OR
b0f3aead3bde16b88a1d6fe669d247b2 ; 114 ; 24 ; 96 ; 21 ; Your adder could actually be simplified further... Take a look at the function as a whole rather than two separate functions for computing S and Cout. For example, see if you can reuse an XOR gate as an input to something else. (If you take a look at the 3 2-input NAND gates you'll notice that they are equal to NAND( XOR(AB)*C ) + NAND(AB). So we can reuse an XOR gate to replace two of the 2-input NAND gates and change the last NAND gate into a two input gate.
c127b489a5c0870c5e8e77715731aa4b ; 76 ; 16 ; 150 ; 42 ; Already answered this question. New change: made the first FA a HA because there's no carry input.
c5fe904072b9eb3e0d22d59e6c0ab9cf ; 96 ; 21 ; 150 ; 42 ; The Cout circuit doesn't have negative logic, so it requires more mosfets. Also, you should combine the calculations of Cout and S into the same circuit to further reduce mosfets.
587c8d2a43ec581df67365aac7ed819f ; 114 ; 24 ; 150 ; 42 ; Although we've been working with 2-input gates so far, it turns out you can have more inputs than that. Where could you use that information to condense?
587c8d2a43ec581df67365aac7ed819f ; 114 ; 24 ; 96 ; 21 ; 1. Don't follow the lab directions.        2. Right now you have two separate circuits computing the two output values. It's possible to combine the circuits and thereby save mosfets.
78c970b7bf86cd374227d0bba36b0f8a ; 114 ; 24 ; 150 ; 42 ; The Cout section of the function can be implemented using three NAND2 gates that feed into a NAND3 gate. It performs the same logic in a more simple way.
78c970b7bf86cd374227d0bba36b0f8a ; 114 ; 24 ; 96 ; 21 ; Tell them to consider integrating the halves of the circuit together to make it more efficient, as opposed to designing a separate circuit for each of the two outputs.
91703887e2bceafe9eaa501369a6d637 ; 114 ; 24 ; 126 ; 27 ; I just followed hints and suggested diagrams
e73ee9120c3b15efa556b1201d5dc581 ; 114 ; 24 ; 126 ; 27 ; I would tell them to think of different ways to complete the circuit without the XOR gate because that is the one that requires the most mosfets
e73ee9120c3b15efa556b1201d5dc581 ; 114 ; 24 ; 96 ; 21 ; Think of a way to combine the S and Cout circuits so they are not completely independent of each other.
dfb20115e6bd161c95c03097b4ff2b4e ; 114 ; 24 ; 132 ; 33 ; They have a redundant number of NANDS and ANDS. They should not use ANDs or ORS since they automatically use more mosfets than NANDS and NORs and are not necessary anyways. 
dfb20115e6bd161c95c03097b4ff2b4e ; 114 ; 24 ; 96 ; 21 ; Instead of implementing the outputs S and Cout seperately, try doing something together so that instead of having to do the logic separately, do it together and you can use less logic gates. 
7f1d5f4b631225184153559428d6181d ; 114 ; 24 ; 132 ; 33 ; I would advise that they try to work with nands and nors instead of ands and ors. I would also probably-not-that-subtly hint at using (and hence writing their own) a 3-input nand or nor.
7f1d5f4b631225184153559428d6181d ; 114 ; 24 ; 96 ; 21 ; I would advice them to think about reusing circuit elements and outputs. Basically, I would advise thinking about getting S and Cout in one integrated circuit instead of in two circuits that happened to use the same inputs.
3210781436a7478d413b98e6bc03ee33 ; 114 ; 24 ; 132 ; 33 ; From the earlier part of the lab (and knowledge of CMOS gates in general), we know it generally requires fewer MOSFETS to build an inverting gate than to build a series of gates such that the output is non-inverting. SO: consider re-thinking some of the non-inverting logic gates we have drawn -- they're a likely place to search for extra MOSFET usage!
3210781436a7478d413b98e6bc03ee33 ; 114 ; 24 ; 96 ; 21 ; Since the FA contains an XOR gate that is used in part S, and we know a XOR gate takes a pretty large # of MOSFETS, and we, of course, have access to the the output of the XORs when calculating the Cout -- is there any way we could re-use the output for the XOR instead of starting our logic from scratch?
cbfd7f958967420a2087ba3486516dfa ; 114 ; 24 ; 132 ; 33 ; There is probably an easier way to either implement the 3 NAND gates with the AND gate or a way that utilizes more naturally inverting CMOS gates like NANDs and NORs that use fewer mosfets
cbfd7f958967420a2087ba3486516dfa ; 114 ; 24 ; 96 ; 21 ; Try to utilize the large XOR logic gate to do some of the logic instead of isolating the two results S and Cout.
88b4a0e50e04ee836a9bba8fc8080413 ; 114 ; 24 ; 132 ; 33 ; Firstly replace AND by NAND and OR by NOR as they use lesser Mosfets. Should try to use a 3 input NAND
88b4a0e50e04ee836a9bba8fc8080413 ; 114 ; 24 ; 96 ; 21 ; Try to eliminate the 3 input NAND by reusing the outputs you found while finding S.  
b21a86566a254f4e822aa67eb4b0e6a1 ; 126 ; 30 ; example=expected ; example=expected ; Your XOR gate did not use the minimal number of mosfets
b21a86566a254f4e822aa67eb4b0e6a1 ; 126 ; 30 ; 96 ; 21 ; Via application of demorgan's theorem, NAND2 (XOR A B) Cin is equivalent to NAND3(NAND2 A B) Cin)
b0278a70acbe552ff50f226c27852f87 ; 102 ; 18 ; 132 ; 33 ; They could make the (B, Cin) a NAND and join it with the other two NANDS, which would save a lot of mosfets.
b0278a70acbe552ff50f226c27852f87 ; 102 ; 18 ; 96 ; 21 ; It is a good idea to use work that was necessary to get the S in order to calculate the Cout.
b77cc55a030960df06ce54cad72e23b3 ; 114 ; 24 ; 144 ; 36 ; I would suggest to use Demorgan's law to try and combine logic and reduce the number of gates.
b77cc55a030960df06ce54cad72e23b3 ; 114 ; 24 ; 96 ; 21 ; To think about S and Cout and find overlap.  Try and design an implementation that combines redundant logic for S and Cout.
4c944da9831665f3be0ee6617085715d ; 114 ; 24 ; 132 ; 36 ; The S part is fine. It is exactly how I did it. For the Cout part, you don't need to have 5 different inputs. I think part of the problem is that you need to reuse some of the pfets and nfets if possible. Although this design also only has 4 total gates, mine was done with 4 nand gates off three inputs, whereas this uses 2 nor, and 2 nand off 5 inputs. 
4c944da9831665f3be0ee6617085715d ; 114 ; 24 ; 96 ; 21 ; I would tell them to be smart and reuse things that we calculate. In my design there is no overlap between the S and the cout components, whereas here, they use the calculated values of xor_ab in their calculation of cout, thus using one less gate than was previously required!
b83ede8053d276826b5f240d53ea3863 ; 114 ; 24 ; 132 ; 36 ; I would suggest the student to have a look at the logic equation and to use De Morgan's Laws in order to reduce it. Also, I would suggest to them that they should not represent the logic in terms of ANDs/ORs, instead they should try to implement it using NANDs exclusively, reminding them that NANDs are universal, which in the process would synthesise some of the logic in the circuit.
b83ede8053d276826b5f240d53ea3863 ; 114 ; 24 ; 96 ; 21 ; I would suggest the student to have a look at identities for XOR and use it for their advantage on the logic for the carry-bit, since we already have a circuit with two XORs which is logic that is basically being unused.
5d2f41f50a6006ce6f184b92b187d9dd ; 114 ; 24 ; 132 ; 36 ; Instead of using 2 ORs and 2 ANDs you can combine them to be 3 2-input NANDs and 1 3-input NAND. It will help using a logic equation.
5d2f41f50a6006ce6f184b92b187d9dd ; 114 ; 24 ; 96 ; 21 ; Instead of separating the subckt for the S portion and the subckt for the Cout portion, think of ways you can combining the circuits for the two.
3b4c8ac73c957b6a9d9a922e8df3300f ; 114 ; 24 ; 132 ; 36 ; For Cout, think about how you can apply demorgan's law to change your ands and ors to nands.
3b4c8ac73c957b6a9d9a922e8df3300f ; 114 ; 24 ; 96 ; 21 ; Consider how you can use elements of the circuit for S and Cout together, instead of doing them in isolation
1634283a36a2753e1795be89974648de ; 126 ; 30 ; example=expected ; example=expected ; 
1634283a36a2753e1795be89974648de ; 126 ; 30 ; 96 ; 21 ; 
5ba71fa37b0e492e4c8ff79a2fce38ea ; 126 ; 30 ; example=expected ; example=expected ; Think carefully about implementing the 3-input nand gate.
5ba71fa37b0e492e4c8ff79a2fce38ea ; 126 ; 30 ; 96 ; 21 ; Remember that the S calculator and the Cout calculator do not have to be isolated systems.
02f5411898d46f77b61c46de589df41f ; 114 ; 24 ; 132 ; 36 ; I would say something like this:        Alright, your circuit seems to work pretty well, however, there may be some ways of making it using fewer mosfets than this way. If we start from the beginning, we can remember that a mosfet is an inverter, and because of that, the logical gates build with mosfets have inverting outputs. The ANDs and ORs do not have inverting outputs, and for this to works they put more mosfets in this gate just to invert its outputs. I would suggest that you think if there is a way you can build a circuit using NANDs and NORs instead of ANDs and ORs, but keep the inputs and outputs unchanged, of course.
02f5411898d46f77b61c46de589df41f ; 114 ; 24 ; 96 ; 21 ; Sometimes we have some operations in a circuit that become repeated. I mean, you may be doing A AND B, in two different places for example. It is a good idea to analyse the circuit and see if there is something you can reuse in order not to build a redundant part of a circuit. The amount of needed mosfets can be greatly reduced doing that.
d23b820a0ded3d27a53dbf518959d10a ; 114 ; 24 ; 132 ; 36 ; Since CMOS is naturally inverting, it would be more efficient to replace AND/ORs for the Cout circuit by applying De Morgan's Laws. Also, you should think about the possibility of having a gate with more than two inputs as a way of reducing the number of MOSFETs.
d23b820a0ded3d27a53dbf518959d10a ; 114 ; 24 ; 96 ; 21 ; As one scenario for improvement, you should consider trying to use your S implementation to save MOSFETs when implementing Cout. By using one or more outputs from the logic chain for S, you might be able to reduce the number of logic gates used to obtain Cout and thereby reduce the number of MOSFETs used.
4caabc02164b371cc380030cbc8d0c18 ; 114 ; 24 ; 132 ; 36 ; Your design for S works. However, your design for Cout doesn't seem to be correct. When A and B are both 1, and Ci is 0, the circuit should still return 1. However, your circuit returns 0. Furthermore, in terms of timing, it's faster (since you'll use less MOSFETs) if you use NAND or NOR gates to construct your circuit. Remember that NAND and NOR gates are lenient so they can build INV, AND, OR.
4caabc02164b371cc380030cbc8d0c18 ; 114 ; 24 ; 96 ; 21 ; You want to optimize timing by reducing the number of MOSFETs you're using. You have three inputs and two outputs. While each output can be thought of as an independent circuit, you can also try to combine the logic. and use an intermediate result from the logic as an input to other gates.
3498236d5434b12ddb4ce0b046bfa3a5 ; 114 ; 24 ; 132 ; 36 ; To get Co, consider using nand gates with 2 and 3 inputs, and use DeMorgan's law to represent and/or logic gates using only the nand gates. 
3498236d5434b12ddb4ce0b046bfa3a5 ; 114 ; 24 ; 96 ; 21 ; I would advise them to consider 2 input nand gates and 2 input XOR gates to get Cout. Use DeMorgan's law to represent and/or logic gates using the above gates. 
6a22e6ccd784e9f36eca664c7b23d6aa ; 114 ; 30 ; 150 ; 42 ; Try to think about the three bit adder as being made up of 2 bit adders.
6a22e6ccd784e9f36eca664c7b23d6aa ; 114 ; 30 ; 96 ; 21 ; Less circuit elements usually means less mosfets.
cef2dfa7661ec4536f4537db8eaad3f2 ; 114 ; 24 ; 150 ; 42 ; Tell them to remove the two OR gates on the bottom, and they can replace them with a 3 input OR. That reduces some mosfets. However to get down to 114 you are going to have to take advantage of the inverting nature of CMOS logic and use three 2 input NAND gates combined with one 3 input NAND gate.
cef2dfa7661ec4536f4537db8eaad3f2 ; 114 ; 24 ; 96 ; 21 ; Instead of having two completely different circuits to compute S and Cout, I would advise the student to connect them. That way they are able to use one gate to do multiple things for them.
ea1f28a86c4176209cf446ccff1bc263 ; 114 ; 24 ; 150 ; 42 ; AND and OR gates can be combined into NAND gates. By De Morgans law, cascaded AND and OR gates are logically equivalent to NANDs.
ea1f28a86c4176209cf446ccff1bc263 ; 114 ; 24 ; 96 ; 21 ; In the implementation of Cout, you can reduce the number of mosfets you use. Instead of using a 3-input NAND gate, you can cascade the output of your XOR gate into one of your NANDs as part of your Cout circuit, eliminating the need for an extra NAND gate.
580213b41999541429074f16a1b10c2d ; 114 ; 24 ; 150 ; 42 ; I would tell them to use inverting logic because it's faster and requires less MOSFETS. I used NANDs and NORs to make my device run faster, and this one uses ANDs and ORs.
580213b41999541429074f16a1b10c2d ; 114 ; 24 ; 96 ; 21 ; I would tell them not to treat the S output and the Cout output as completely separate. They could combine outputs to create logic that would make the device run faster because it wouldn't have to recompute things.
134342a486c43ac195becd6098bd41eb ; 114 ; 24 ; 150 ; 42 ; An AND followed by and OR is equivalent to a NAND followed by a NAND so replace the two ORS with a single NAND3 and the three ANDS by NANDs.
134342a486c43ac195becd6098bd41eb ; 114 ; 24 ; 96 ; 21 ; Try reusing already available values.
71e6c2f4b1bb19a37a33f31b7c039635 ; 114 ; 24 ; 150 ; 42 ; The circuit above uses many ands and ors rather than nands and nors. Ands and ors require more mosfets to build because they have to be inverted before the gate is constructed. This is because in the logic table, all low inputs must result in a high and all high inputs must result in a low (as pfets are on when 0 and nfets are on when 1) for the gate to be built using mosfets. This makes it more straightforward and economical to build nands and nors using mosfets rather than ands and ors. Ands require 6 mosfets while nands require 4, so it is more efficient to design the circuit using nands. 
71e6c2f4b1bb19a37a33f31b7c039635 ; 114 ; 24 ; 96 ; 21 ; Most designs separate the S and Cout into 2 separate circuits, which will require more gates than if you interweave the circuits as shown in the diagram. The circuit can save a lot of mosfets by using the xor from the S output and using it in the Cout logic. The circuit above substitutes (A NAND Cin)NAND(B NAND Cin) with Cin NAND (A XOR B). This significantly reduced the number of mosfets needed because we no longer need two of the nand gates and the 3 input nand is also replaced with a 2 input nand. Essentially, the circuit is created using less mosfets due to the fact that the two output logics are combined so that certain parts of the circuit, for example the xor gate, is used for both outputs, making it more economical. 
0830b704dfbf0ad1f5f46b907e04ef0a ; 114 ; 24 ; 150 ; 42 ; Try to combine ANDs and ORs into NANDs and NORs. Not only do they reduce the number of gates, but NANDs/NORs require fewer MOSFETs than ANDs and ORs.
0830b704dfbf0ad1f5f46b907e04ef0a ; 114 ; 24 ; 96 ; 21 ; Try to find a way to combine S lines and Cout lines -- this may be tricky but will allow for multiples uses of a given NAND or NOR gate.
bf23216e6e6e534e3decdd7f4423cdcb ; 114 ; 24 ; 150 ; 42 ; I would tell them to think about what 3 input device they can use to replace the two ORs
bf23216e6e6e534e3decdd7f4423cdcb ; 114 ; 24 ; 96 ; 21 ; I would tell them that the circuit can be built using XORs and NANDs and to consider using part of the output from one half of the circuit as an input in the other, rather than keeping the paths for the two outputs discrete.
af2eec02ed0ec14c77a508dee62f1279 ; 114 ; 24 ; 150 ; 42 ; Consider your calculation of Cout. Instead, consider using less mosfet-using NANDS. Hint: using DeMorgan's Law, you can use derive an expression using only 3 two-input NANDS and 1 triple-input NAND.
af2eec02ed0ec14c77a508dee62f1279 ; 114 ; 24 ; 96 ; 21 ; Try integrating the calculation of S and C-out, reusing logic from triple-input Xor-calculation of S in the computation of C_out.
c6f98dc0889670edce023a3459c722bc ; 114 ; 24 ; 150 ; 42 ; You should try to apply Demorgan's Law on the Cout part so that it takes less mosfets.
c6f98dc0889670edce023a3459c722bc ; 114 ; 24 ; 96 ; 21 ; Try not to calculate S and Cout separately. Instead, make use of their overlapped part so that your system uses less mosfets.
e6386fcb7629a21dbb1ab8ca8d0c0122 ; 126 ; 30 ; example=expected ; example=expected ; make a 3 input NAND subckt instead of trying to stick to 2 input NANDs. Each NAND3 only uses 6 mosfets, your current design of two NAND2s and an INV uses 10
e6386fcb7629a21dbb1ab8ca8d0c0122 ; 126 ; 30 ; 96 ; 21 ; When trying to minimize the number of mosfets used, it makes sense to try and use an xor for Cout since you've already used it for S. Compared to your design, the use of the xor saves 10 mosfets per FA.
6666d828c45d05bbeb1e28606aebd090 ; 114 ; 24 ; 150 ; 42 ; Remember to use the fact that NAND Gates are superior to AND/OR Gate combination
6666d828c45d05bbeb1e28606aebd090 ; 114 ; 24 ; 96 ; 21 ; Instead of making the S and Cout components individual, combine them together to save computation power
97784d2f03a9aa2f65f932974fc99046 ; 114 ; 24 ; 150 ; 42 ; The student implemented S efficiently, using two cascaded 2-input XOR gates. However, Cout could have been implemented a bit more efficiently with fewer mosfets. The student used ANDs and ORs in a sum-of-products implementation, but for speed, he/she could have used three 2-input NANDs and one 3-input NAND. Each NAND only takes 4 mosfets, and the 3-input NAND takes 6 mosfets. On the other hand, each AND takes 4 mosfets, while OR can take 6 mosfets (if we implement it using NOR, with an inverter)
97784d2f03a9aa2f65f932974fc99046 ; 114 ; 24 ; 96 ; 21 ; I would primarily suggest changing the diagram for Cout. In my solution, I was using a 3-input NAND gate, which is expensive in mosfets. (I had three NAND gates, each for AB, BC, and AC) Instead, I would advise the student to consider on how to use the output from the XOR gate (from A and B), and combine that with Cin into the input for another NAND gate. Then if we take this output with the output from the AB NAND gate, we can use just one more NAND gate with 2 inputs to get our final Cout. In other words, we are utilizing the output from an XOR gate (which we already have to compute for S), and using that value for a NAND gate.
738c949ff7544d0f66bfb008e02254e3 ; 114 ; 24 ; 150 ; 42 ; One way to decrease the number of mosfets is to improve the path that gives Cout. One simplification is that the system suggested in the above example uses two cascaded OR2 gates in order to achieve an OR3 gate. The design could use an OR3 gate instead without introducing considerable delays due to gate capacitance if the gate is built with CMOS logic, decreasing the gate count. Another improvement is that the AND2 gates and OR3 gate could be replaced with a composition of inverting gates. Inverting gates use 2 fewer mosfets than their noninverting counterparts in CMOS.
738c949ff7544d0f66bfb008e02254e3 ; 114 ; 24 ; 96 ; 21 ; I would encourage the student to consider that some intermediates in evaluating Cout can be taken directly from the chain to produce S, and this would save on gates.
dc1bb19828d971f7906de3afae22f07e ; 114 ; 24 ; 150 ; 42 ; For Cout, instead of using both and and or gates, they could use 3 2-input nand gates as the inputs to a single 3-input nand gate.
dc1bb19828d971f7906de3afae22f07e ; 114 ; 24 ; 96 ; 21 ; While my Cout was produced using a 3-input nand gate, it appears that it is possible to produce an equivalent Cout with nand and nor gates, which this person then combined with the inputs to s to be ore efficient.
87f524b9c40a851b6d7a096814131eeb ; 114 ; 24 ; 150 ; 42 ; Use more NANDs and NORs instead of ANDs and Ors
87f524b9c40a851b6d7a096814131eeb ; 114 ; 24 ; 96 ; 21 ; Use more NANDs instead of NANDs of NORs
8b12a43c2194a18f23ab82fbbf61b167 ; 114 ; 24 ; 150 ; 42 ; Well done with S. To improve your circuit for Cout, you can use DeMorgan's Law to get to an expression that uses only 1 type of gate we learned about (NAND).
8b12a43c2194a18f23ab82fbbf61b167 ; 114 ; 24 ; 96 ; 21 ; Try to merge your calculations, so that you're not computing S and Cout separately. Can some of your intermediate outputs to gates in the circuit for S be used in the circuit for Cout (or vice versa)? You can start with (S= A xor B xor C) and (Cout= AB+AC+BC). Try to show that (A xor B) can be used to calculated Cout (from the S circuit).
c888fbf2304f393c732d708a0cca9b49 ; 96 ; 21 ; 150 ; 42 ; I would tell them when implementing in CMOS, it is a lot better to use NAND and NOR gates rather than AND and OR gates. This is because MOSFETS are naturally inverting so it takes less MOSFETS to implement a NAND or a NOR gate than it does an AND or an OR gate.
9158734e4b7a59bf335376ef2f7dfd33 ; 114 ; 24 ; 150 ; 42 ; Think about how using the universality of NAND and NOR gates to simplify your circuit. Using DeMorgan's laws, you can consolidate your Cout circuit and use fewer gates.
9158734e4b7a59bf335376ef2f7dfd33 ; 114 ; 24 ; 96 ; 21 ; Whenever you have more than one output that rely on the same inputs, rather than building the two circuits independently, see how you can compute logic that feeds into both outputs. This will save on computations and allow you to lower the amount of mosfets needed.
f316bbd0588c77c092add9216960fe58 ; 114 ; 24 ; 150 ; 42 ; Remember that cascading three two-input NANDS with a three-input NAND operates as an AND/OR logic due to Demorgen's law.
f316bbd0588c77c092add9216960fe58 ; 114 ; 24 ; 96 ; 21 ; Try incorporating the output of one of your CMOS gates for S into your calculation of Cout. Instead of three two-input NANDs and one three-input NAND, you should be able to use only three two-input NANDs.
32d40762f5f54a3d8dd580784e66a52c ; 114 ; 24 ; 150 ; 42 ; Instead of making a circuit with 2-input gates, make a single 3-input gate with nfets and pfets. 
32d40762f5f54a3d8dd580784e66a52c ; 114 ; 24 ; 96 ; 21 ; How can you use intermediate outputs to make a single, integrated circuit?
ea0e501741d0da16ffad5088abff6f51 ; 114 ; 24 ; 126 ; 27 ; I would ask them to write out the equations and rearrange them to only use NAND and XOR gates.
ea0e501741d0da16ffad5088abff6f51 ; 114 ; 24 ; 96 ; 21 ; I would hint that the same gates could be used for both outputs.
1209562f7719760f6fe213fcc6f4925a ; 114 ; 24 ; 126 ; 27 ; To decrease the number of MOSFETs you can take the output of same XOR gate you used to calculate the S variable and use it to calculate Cout
1209562f7719760f6fe213fcc6f4925a ; 114 ; 24 ; 96 ; 21 ; Although this design uses fewer MOSFETs the longest path length is still longer than the design that utilizes the three input NAND. If you want to decrease the number of MOSFETs, simplifying the cases and reusing the output of other MOSFETs would help.
09ce0fa5e5360f62a137aa0bfe877409 ; 114 ; 24 ; 126 ; 27 ; For Cout, use 3 2-input NANDs and a 3-input NAND, instead of the XOR and NAND combination. 
09ce0fa5e5360f62a137aa0bfe877409 ; 114 ; 24 ; 96 ; 21 ; Instead of treating the S output and Cout outputs as two separate circuits within the FA module, try utilizing some of the intermediate nodes (outputs of gates in one circuit that aren't the final output) to avoid redundancy.
46f71919829910839328c2e6d403d8ef ; 114 ; 24 ; 126 ; 27 ; Instead of using an XOR in the cout implementation, which uses 10 mosfets, if you rearrange the gate logic such that (a,b), (a,cin), (b,cin) are each nanded using a 2 input nand and then use a 3 input nand to nand all three pairings, the number of mosfets you need to utilize would decrease, since the 3 input nand would only require 6 mosfets. 
46f71919829910839328c2e6d403d8ef ; 114 ; 24 ; 96 ; 21 ; By utilizing the output of the first XOR in S, you can implement Cout without having to use a 3 input nand which would require 6 extra mosfets rather than taking advantage of the gates that are currently in use.
96ec832cc45620803b4eb65a27f7d59e ; 114 ; 24 ; 126 ; 27 ; I would tell them to re-read the lab, because the lab states "You can use ANDs and ORs in a sum-of-products implementation for Cout, but for speed think about using three 2-input NANDs and one 3-input NAND to implement Cout (remember that by Demorgan's Law two cascaded NANDs are logically equivalent to a cascade of AND/OR)."    
96ec832cc45620803b4eb65a27f7d59e ; 114 ; 24 ; 96 ; 21 ; I would tell them to think about all the different possible representations and which use the least number of mosfets.
46c8860307bcbccc032660002681d82e ; 114 ; 24 ; 126 ; 27 ; I would advise them to compress the S gate by making it into a single CMOS gate
46c8860307bcbccc032660002681d82e ; 114 ; 24 ; 96 ; 21 ; Try to reuse some computation in the calculation of S to calculate Cout
751d19e2c7fcc73b2bf8f1f7f5ab1e27 ; 114 ; 24 ; 126 ; 27 ; There is no need to use the XOR with the NANDS, we can just get rid of the XOR and use two NANDS to get A NAND Cin and B NAND Cin
751d19e2c7fcc73b2bf8f1f7f5ab1e27 ; 114 ; 24 ; 96 ; 21 ; You can potentially use the output from the XOR to create A NAND Cin and B NAND Cin using the output from the XOR that you have already computed and NAND gate.
ea225089bdeab2375f0441fdd184f95c ; 114 ; 24 ; 126 ; 27 ; Use a cascade of 3 NAND2's into NAND3 for Cout
ea225089bdeab2375f0441fdd184f95c ; 114 ; 24 ; 96 ; 21 ; 
a4821c015650c5190af94f506aeee17d ; 114 ; 24 ; 126 ; 27 ; Cout can be reduced by utilizing a 3-input NAND gate.  Given how the full bit adder is constructed how would you go about reducing the number of gates utilized in the current design?
a4821c015650c5190af94f506aeee17d ; 114 ; 24 ; 96 ; 21 ; Instead of computing S and Cout as two seperate entities how can combine the two? In other words what outputs are shared and use values that are needed for both calculations.  Looking at this you can reduce the number of mosfets in use.
6cdf79cd45967abd5969596b844e42b6 ; 114 ; 24 ; 126 ; 27 ; Can reduce the number of mosfets used to build C_out by building three 2NANDs and one 3NANDs.
6cdf79cd45967abd5969596b844e42b6 ; 114 ; 24 ; 96 ; 21 ; Can utilize outputs from both parts (S and C_out) together to save mosfets; do this instead of building separate components for S and C_out.
7c03b8f0f9e9df57618706fa3980ce80 ; 162 ; 42 ; example=expected ; example=expected ; use a three-input nand gate
7c03b8f0f9e9df57618706fa3980ce80 ; 162 ; 42 ; 96 ; 21 ; combine your systems for S and Cout
c2d1c439ba86fe4ad3ab246adb7f06be ; 114 ; 24 ; 144 ; 36 ; Consolidate inputs...There are two XORs that have inputs from A and B, you could implement that XOR gate a single time with those inputs and branch the output to wherever it needs to go. Each XOR is implemented with 10 mosfets in my design, and that extra unnecessary XOR in this design accounts for the extra 30 mosfets (across 3 FA's...)
c2d1c439ba86fe4ad3ab246adb7f06be ; 114 ; 24 ; 96 ; 21 ; I'd tell them to keep their S logic the same, but think about how to better implement Cout. It is possible to implement Cout with NAND2's stemming from the information gleaned from the A-B XOR2 gate used in the S logic.
ebfa1908ffa68372fee51dd04cae2736 ; 114 ; 24 ; 144 ; 36 ; You can have a more efficient way to create Cout. Try thinking about another way to represent Cout but only with using NANDS (hint: consider both 2 and 3 input)
ebfa1908ffa68372fee51dd04cae2736 ; 114 ; 24 ; 96 ; 21 ; Use intermediaries steps between S to help you get Cout. Some calculations are done twice -- once for S and once for Cout. They can use the same subcircuit however. 
82c8ced1bb03c08b34693e9fd4a7c853 ; 114 ; 24 ; 144 ; 36 ; Try thinking of ways to concatenating or reorganizing the Cout chain.
82c8ced1bb03c08b34693e9fd4a7c853 ; 114 ; 24 ; 96 ; 21 ; Try to identify places where instead of adding a mosfet, we can use a result of gates we've built already. 
00b208e55d22484fc032990a40d6eaa6 ; 114 ; 24 ; 144 ; 36 ; Use DeMorgan's law to turn the non-inverting gates into inverting ones.
00b208e55d22484fc032990a40d6eaa6 ; 114 ; 24 ; 96 ; 21 ; Reuse gates from different parts of the circuit. I.E.: you don't have to treat S and Co as if they're separate logic functions that exist in a vacuum.
13b9881993281a7256772b938354dda1 ; 114 ; 24 ; 144 ; 36 ; The design for finding S looks good, but the design for Cout uses an unnecessary XOR. Knowing that XOR uses 10 mosfets in itself, could you try to find Cout without using an XOR? Also, since A, B, and Cin are symmetric and interchangeable, is there any way to design the Cout circuit to also be symmetric among all three of A, B, and Cin?
13b9881993281a7256772b938354dda1 ; 114 ; 24 ; 96 ; 21 ; So you designed the circuit using the inputs independently for S and Cout. Is there any way you could use the intermediate nodes of either S or Cout to make the solution for the other more efficient? Remember, if you use an intermediate node from one of them, you don't need more mosfets to use that voltage, so you could be killing two birds with one stone!
4fce8caa2ff5e29ee8b71d8e9d56fbeb ; 114 ; 24 ; 132 ; 36 ; I would tell him to think about the propagation delays of signals through logic gates, and hopefully he would realize that we want to decrease the size of the longest path to the output to theoretically increase run speed.
4fce8caa2ff5e29ee8b71d8e9d56fbeb ; 114 ; 24 ; 96 ; 21 ; This would require a better look at the circuit logic.  I suppose I would remind the student to use K-maps (which I assume led to the discovery of this implementation).  
4d417eafd1f7f919aae5f3f88ad30507 ; 126 ; 30 ; example=expected ; example=expected ; Take the time to implement a 3-input nand gate. Even though you are only given the template for a 2-input gate, it's not difficult to modify it to test for 3 inputs.
4d417eafd1f7f919aae5f3f88ad30507 ; 126 ; 30 ; 96 ; 21 ; Realize that you can yield multiple different outputs with the same combinational logic. Also note that because say a value of Cin = 0 will yield 1 for both nand gates in the previous implementation (Comparison 1), you can essentially take it out. Cin is not unique as our inputs are cyclic, so you could take any of our inputs out in the same manner.        With that said, doesn't this have a greater propagation delay than the previous implementation (Comparison 1)
442f10b9333f9823bc7b1d095131b449 ; 114 ; 30 ; 132 ; 36 ; You can use the output of your XOR of A and B to make your component that calculates Cout require less mosfets. 
442f10b9333f9823bc7b1d095131b449 ; 114 ; 30 ; 96 ; 21 ; Try to find out where you are redundantly inverting.
3d56b4651c70259dcd6400dc33b5e575 ; 114 ; 24 ; 132 ; 36 ; I would recommend using three 2-input nand gates and one 3-input nand gate to calculate Cout.
3d56b4651c70259dcd6400dc33b5e575 ; 114 ; 24 ; 96 ; 21 ; I would recommend the students to not calculate S and Count separately but rather using the intermediate nodes of S to calculate Cout.
25bf1753a4d6461c4e2994e7299eb224 ; 126 ; 30 ; example=expected ; example=expected ; I would tell them to make sure their logic gates use the fewest number of mosfets.
25bf1753a4d6461c4e2994e7299eb224 ; 126 ; 30 ; 96 ; 21 ; I would tell them to think more about how to use fewer gates in their design by reusing results of gates.
f7981d40b0067ac0a323be49dd67e986 ; 114 ; 24 ; 150 ; 42 ; We could simplify the gates more if we use a NAND tree.
f7981d40b0067ac0a323be49dd67e986 ; 114 ; 24 ; 96 ; 21 ; By using the output of one of the XOR's, we are able to reduce the number of gates. 
d9593edf2bdcf027536b6eae68cce56c ; 114 ; 24 ; 150 ; 42 ; For speed try using three 2-input NANDs and oen 3-input NAND to replace the cascade of ANDs and ORs when implementing Cout. 
d9593edf2bdcf027536b6eae68cce56c ; 114 ; 24 ; 96 ; 21 ; When implementing Cout, try to find equivalent logic expression so that you can replace exactly one AND by XOR, and then, use the intermediate XOR results from computing S. 
97d3fd0497aa02beea4b73a747db8f76 ; 114 ; 24 ; 126 ; 27 ; Change to my circuit design.
97d3fd0497aa02beea4b73a747db8f76 ; 114 ; 24 ; 96 ; 21 ; This circuit is bad! Total t_PD is bigger than mine, because there is one more XOR gate in the critical path. D:
8d6ab4e850871bd1d2ebc90da31d1037 ; 96 ; 21 ; 132 ; 33 ; You should always try to use negative logic as it is smaller and faster than positive logic. Thus you should replace your AND(B, Cin) logic gate with NAND(B, Cin) and replace your NAND and OR gate with a 3-input NAND gate. This will allow you to use far less mosfets in your solution.        Also, you should combine the calculation of S and Cout by combining the two logic gates, as this will also reduce the total number of mosfets needed. As a hint, keep in mind that (A XOR B)*C is logically equivalent to ((A*C)+(B*C))*NOT(A*B).
c11ef72b990ce6b94ace78e360b4fb22 ; 114 ; 24 ; 132 ; 33 ; Build a NAND3
c11ef72b990ce6b94ace78e360b4fb22 ; 114 ; 24 ; 96 ; 21 ; Try to think of how you can use the information from your 2 XOR's to help design Cout.
01091d3ce86e77a2fd39f92f7cb1985f ; 114 ; 24 ; 132 ; 33 ; Try to use negative logic (NAND and NOR) as much as possible, because they use fewer mosfets than positive logic (AND and OR). This is because a single CMOS circuit will inherently encode negative logic. Currently, the circuit uses one AND and one OR, so try to replace them with other negative alternatives (not necessary binary!).
01091d3ce86e77a2fd39f92f7cb1985f ; 114 ; 24 ; 96 ; 21 ; Instead of using three NAND2's and one NAND3's for Cout, try to recycle some of the values used in computing S. For example, A xor B is an intermediate value in computing S, and try to simplify Cout using DeMorgan's Law. It may be helpful to note that A+B and A xor B differ only when A = 1 and B = 1, which suggests that using A xor B instead of A+B can be fine under certain conditions.
e37e10af504af607c86ae62ad1fe09cf ; 114 ; 24 ; 132 ; 33 ; Simplify the cascade of AND and OR to a single NOR3 gate.
e37e10af504af607c86ae62ad1fe09cf ; 114 ; 24 ; 96 ; 21 ; Make one simpler circuit instead of two separate ones for outputs S and Cout